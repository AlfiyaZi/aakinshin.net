<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andrey Akinshin's blog</title>
  <link href="http://aakinshin.net"/>
  <link type="application/atom+xml" rel="self" href="http://aakinshin.net/en/atom.xml"/>
  <updated>2015-03-01T06:17:16.8731895Z</updated>
  <id>http://aakinshin.net/</id>
  <author>
    <name>Andrey Akinshin</name>
    <email>andrey.akinshin@gmail.com</email>
  </author>

          <entry>
              <id>http://aakinshin.net/en/blog/dotnet/ryujit-ctp5-and-loop-unrolling/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dotnet/ryujit-ctp5-and-loop-unrolling/'/>
              <title>RyuJIT CTP5 and loop unrolling</title>
              <updated>2015-03-01T00:00:00Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;RyuJIT will be available soon. It is a next generation JIT-compiler for .NET-applications. Microsoft likes to tell us about the benefits of SIMD using and JIT-compilation time reducing. But what about basic code optimization which is usually applying by a compiler? Today we talk about the loop unrolling (unwinding) optimization. In general, in this type of code optimization, the code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;for (int i = 0; i &amp;lt; 1024; i++)
    Foo(i);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;transforms to&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;for (int i = 0; i &amp;lt; 1024; i += 4)
{
    Foo(i);
    Foo(i + 1);
    Foo(i + 2);
    Foo(i + 3);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Such approach can significantly increase performance of your code. So, what&#39;s about loop unrolling in .NET?&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3&gt;Common theory&lt;/h3&gt;
&lt;p&gt;First of all, let&#39;s talk about how loop unrolling affects to our applications.&lt;/p&gt;
&lt;h4&gt;Advantages&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;We are reducing the number of machine commands (iterator increments).&lt;/li&gt;
&lt;li&gt;Reduced overheads of &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;branch prediction&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;We increase the possibility of using &lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction-level_parallelism&quot;&gt;instruction-level parallelism&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;We can apply additional code improvements in conjunction with other optimizations (e. g. , &lt;a href=&quot;http://en.wikipedia.org/wiki/Inline_expansion&quot;&gt;inlining&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Disadvantages&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;The source code size increased.&lt;/li&gt;
&lt;li&gt;Sometimes, due to the increasing size of the instruction amount, it is impossible to simultaneously apply loop unrolling and inlining.&lt;/li&gt;
&lt;li&gt;Possible &lt;a href=&quot;http://en.wikipedia.org/wiki/CPU_cache#Cache_miss&quot;&gt;cache misses&lt;/a&gt; in the commands cache.&lt;/li&gt;
&lt;li&gt;Possible increased register usage in a single iteration (we may not have enough registers, other optimizations can not apply because of registers deficit).&lt;/li&gt;
&lt;li&gt;If there is branching in the iteration, loop unrolling can adversely affect to other optimizations.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;Loop unrolling is a very powerful tool for optimization, but only if we use it wisely. I don&#39;t recommended apply it yourself: it will reduce the readability of the source code and it can adversely affect to use other optimizations. It is best to leave this approach to the compiler. It is important that your compiler could do loop unrolling competently.&lt;/p&gt;
&lt;h3&gt;Experiments&lt;/h3&gt;
&lt;h4&gt;Source code&lt;/h4&gt;
&lt;p&gt;We will work with a very simple loop which is very easy to unroll:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int sum = 0;
for (int i = 0; i &amp;lt; 1024; i++)
    sum += i;
Console.WriteLine(sum);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note, the amount of iterations is known beforehand and it is equal to 2&lt;sup&gt;10&lt;/sup&gt;. It is very important because it greatly simplifies usage of the considered optimization.&lt;/p&gt;
&lt;h4&gt;JIT-x86&lt;/h4&gt;
&lt;p&gt;Let&#39;s run the code with JIT-x86 and look to the assembler code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;                    
00EE0052  in          al,dx             
00EE0053  push        esi               
00EE0054  xor         esi,esi           
        for (int i = 0; i &amp;lt; 1024; i++)  
00EE0056  xor         eax,eax           
            sum += i;                   
00EE0058  add         esi,eax           ; sum += i
        for (int i = 0; i &amp;lt; 1024; i++)  
00EE005A  inc         eax               ; i++
00EE005B  cmp         eax,400h          
00EE0060  jl          00EE0058          
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, JIT-x86 didn&#39;t apply loop unrolling. You should understood, the 32-bit version of JIT-compiler is quite primitive. I have never ever seen, JIT-x86 unroll at least one loop.&lt;/p&gt;
&lt;h4&gt;JIT-x64&lt;/h4&gt;
&lt;p&gt;Next, try the experiment with the 64-bit version of JIT-compiler:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;                               
00007FFCC8710090  sub         rsp,28h              
        for (int i = 0; i &amp;lt; 1024; i++)             
00007FFCC8710094  xor         ecx,ecx              
00007FFCC8710096  mov         edx,1                ; edx = i + 1
00007FFCC871009B  nop         dword ptr [rax+rax]  
00007FFCC87100A0  lea         eax,[rdx-1]          ; eax = i
            sum += i;                              
00007FFCC87100A3  add         ecx,eax              ; sum += i
00007FFCC87100A5  add         ecx,edx              ; sum += i + 1
00007FFCC87100A7  lea         eax,[rdx+1]          ; eax = i + 2
00007FFCC87100AA  add         ecx,eax              ; sum += i + 2;
00007FFCC87100AC  lea         eax,[rdx+2]          ; eax = i + 3
00007FFCC87100AF  add         ecx,eax              ; sum += i + 3;
00007FFCC87100B1  add         edx,4                ; i += 4
        for (int i = 0; i &amp;lt; 1024; i++)             
00007FFCC87100B4  cmp         edx,401h             
00007FFCC87100BA  jl          00007FFCC87100A0     
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, loop unrolling have been applied, the loop body repeated 4 times. JIT-x64 is able to repeat the loop body 2, 3 or 4 times (it depends on the amount of iterations). Unfortunately, if there are no 2, 3, 4 in the set of iterations amount divisors, loop unrolling will not be applied.&lt;/p&gt;
&lt;h4&gt;RyuJIT&lt;/h4&gt;
&lt;p&gt;What&#39;s about new RyuJIT? Let&#39;s look to the assembler code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;                            
00007FFCC86E0091  sub         rsp,20h           
00007FFCC86E0095  xor         esi,esi           
        for (int i = 0; i &amp;lt; 1024; i++)          
00007FFCC86E0097  xor         eax,eax           
            sum += i;                           
00007FFCC86E0099  add         esi,eax           ; sum += i
        for (int i = 0; i &amp;lt; 1024; i++)          
00007FFCC86E009B  inc         eax               ; i++
00007FFCC86E009D  cmp         eax,400h          
00007FFCC86E00A2  jl          00007FFCC86E0099  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A sad situation: RyuJIT can&#39;t unroll even the simplest loop.&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;RyuJIT allows us to use SIMD-instructions and reduces the JIT compilation time. Unfortunately, the performance of the resulted code with the transition to the new JIT can reduce. Note, there is no the final RuyJIT, the experiment was conducted for CTP5. Let&#39;s hope that the RyuJIT release will include smart code optimizations.&lt;/p&gt;
&lt;h3&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Loop_unrolling&quot;&gt;Wikipedia: Loop unrolling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.researchgate.net/publication/2449271_Generalized_Loop-Unrolling_a_Method_for_Program_Speed-Up&quot;&gt;J. C. Huang, T. Leng, Generalized Loop-Unrolling: a Method for Program Speed-Up (1998)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Wikipedia: Branch prediction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction-level_parallelism&quot;&gt;Wikipedia: Instruction-level parallelism&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Inline_expansion&quot;&gt;Wikipedia: Inline expansion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/CPU_cache#Cache_miss&quot;&gt;Wikipedia: Cache miss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/2349211/when-if-ever-is-loop-unrolling-still-useful&quot;&gt;StackOverflow: http://stackoverflow.com/questions/2349211/when-if-ever-is-loop-unrolling-still-useful&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dotnet/jit-version-determining-in-runtime/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dotnet/jit-version-determining-in-runtime/'/>
              <title>JIT version determining in runtime</title>
              <updated>2015-02-28T00:00:00Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;Sometimes I want to know used JIT compiler version in my little C# experiments. It is clear that it is possible to determine the versopm in advance based on the environment. However, sometimes I want to know it in runtime to perform specific code for the current JIT compiler. More formally, I want to get the value from the following enum:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public enum JitVersion
{
    Mono, MsX86, MsX64, RyuJit
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is easy to detect Mono by existing of the &lt;code&gt;Mono.Runtime&lt;/code&gt; class. Otherwise, we can assume that we work with Microsoft JIT implementation. It is easy to detect JIT-x86 with help of &lt;code&gt;IntPtr.Size == 4&lt;/code&gt;. The challenge is to distinguish JIT-x64 and RyuJIT. Next, I will show how you can do it with help of the bug from my &lt;a href=&quot;http://aakinshin.net/en/blog/dotnet/subexpression-elimination-bug-in-jit-x64/&quot;&gt;previous post&lt;/a&gt;.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;First of all, I show a trivial code that helps us to detect the &lt;code&gt;JitVersion.Mono&lt;/code&gt; and &lt;code&gt;JitVersion.MsX86&lt;/code&gt; versions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static bool IsMono()
{
    return Type.GetType(&amp;quot;Mono.Runtime&amp;quot;) != null;
}

public static bool IsMsX86()
{
    return !IsMono() &amp;amp;&amp;amp; IntPtr.Size == 4;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we will learn to detect &lt;code&gt;JitVersion.MsX64&lt;/code&gt;. We will use &lt;a href=&quot;http://aakinshin.net/en/blog/dotnet/subexpression-elimination-bug-in-jit-x64/&quot;&gt;the JIT-x64 sub-expression elimination optimizer bug&lt;/a&gt; for this purpose. Note, that you should compile the program with enabled optimizations.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private int bar;

private bool IsMsX64(int step = 1)
{
    var value = 0;
    for (int i = 0; i &amp;lt; step; i++)
    {
        bar = i + 10;
        for (int j = 0; j &amp;lt; 2 * step; j += step)
            value = j + 10;
    }
    return value == 20 + step;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this post, we work with a limited set of JIT-compiler. Therefore RyuJIT can be identified by the elimination method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public JitVersion GetJitVersion()
{
    if (IsMono())
        return JitVersion.Mono;
    if (IsMsX86())
        return JitVersion.MsX86;
    if (IsMsX64())
        return JitVersion.MsX64;
    return JitVersion.RyuJit;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everything is ready! Let&#39;s write a simple program, which determine the JIT version in runtime:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;

class Program
{
    public enum JitVersion
    {
        Mono, MsX86, MsX64, RyuJit
    }

    public class JitVersionInfo
    {
        public JitVersion GetJitVersion()
        {
            if (IsMono())
                return JitVersion.Mono;
            if (IsMsX86())
                return JitVersion.MsX86;
            if (IsMsX64())
                return JitVersion.MsX64;
            return JitVersion.RyuJit;
        }

        private int bar;

        private bool IsMsX64(int step = 1)
        {
            var value = 0;
            for (int i = 0; i &amp;lt; step; i++)
            {
                bar = i + 10;
                for (int j = 0; j &amp;lt; 2 * step; j += step)
                    value = j + 10;
            }
            return value == 20 + step;
        }

        public static bool IsMono()
        {
            return Type.GetType(&amp;quot;Mono.Runtime&amp;quot;) != null;
        }

        public static bool IsMsX86()
        {
            return !IsMono() &amp;amp;&amp;amp; IntPtr.Size == 4;
        }
    }

    static void Main()
    {
        Console.WriteLine(&amp;quot;Current JIT version: &amp;quot; + new JitVersionInfo().GetJitVersion());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And a small bat file for checking of results:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;csc /platform:x86 /warn:0 /nologo Program.cs
mono Program.exe
Program.exe
csc /platform:x64 /optimize /warn:0 /nologo Program.cs
mono Program.exe
SET COMPLUS_AltJit=0
Program.exe
SET COMPLUS_AltJit=*
Program.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&#39;s make sure that everything is correct:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/jit-version-determining-in-runtime/screen.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;The class is ready to use! The complete code is also available on Gist: &lt;a href=&quot;https://gist.github.com/AndreyAkinshin/0506ad10faf0c2a7b1cb&quot;&gt;JitVersionInfo.cs&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Method of distinguish MsX64 and RyuJIT works only with enabled optimizations.&lt;/li&gt;
&lt;li&gt;The approach works with a limited set of JIT versions, you can have troubles with non-standard .NET versions.&lt;/li&gt;
&lt;li&gt;Miguel have promised that Mono 4 will work on CoreCLR which means RyuJIT.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://aakinshin.net/en/blog/dotnet/subexpression-elimination-bug-in-jit-x64/&quot;&gt;A bug story about JIT-x64&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/721161/184842&quot;&gt;StackOverflow: How to detect which .NET runtime is being used (MS vs. Mono)?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/22422021/184842&quot;&gt;StackOverflow: How do I verify that ryujit is jitting my app?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dotnet/subexpression-elimination-bug-in-jit-x64/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dotnet/subexpression-elimination-bug-in-jit-x64/'/>
              <title>A bug story about JIT-x64</title>
              <updated>2015-02-27T00:00:00Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;Can you say, what will the following code display for &lt;code&gt;step=1&lt;/code&gt;?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Foo(int step)
{
    for (int i = 0; i &amp;lt; step; i++)
    {
        bar = i + 10;
        for (int j = 0; j &amp;lt; 2 * step; j += step)
            Console.WriteLine(j + 10);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you think about specific numbers, you are wrong. The right answer: it depends. The post title suggests to us, the program can has a strange behavior for x64.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;The problem statement&lt;/h3&gt;
&lt;p&gt;The bug isn&#39;t a new one, it has been discussed a year ago on StackOverflow: &lt;a href=&quot;http://stackoverflow.com/questions/20701701/jit-net-compiler-bug&quot;&gt;“JIT .Net compiler bug?”&lt;/a&gt;. However, the code from the question is too complicated for an analysis. I have tried to minimize it for the future examination. Let&#39;s consider the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Runtime.CompilerServices;

class Program
{
    static void Main()
    {
        new Program().Run();
    }

    private void Run()
    {
        Console.WriteLine(&amp;quot;Optimization:&amp;quot;);
        Optimization(1);
        Console.WriteLine(&amp;quot;NoOptimization:&amp;quot;);
        NoOptimization(1);
    }

    int bar;

    public void Optimization(int step)
    {
        for (int i = 0; i &amp;lt; step; i++)
        {
            bar = i + 10;
            for (int j = 0; j &amp;lt; 2 * step; j += step)
                Console.WriteLine(j + 10);
        }
    }

    [MethodImpl(MethodImplOptions.NoOptimization)]
    public void NoOptimization(int step)
    {
        for (int i = 0; i &amp;lt; step; i++)
        {
            bar = i + 10;
            for (int j = 0; j &amp;lt; 2 * step; j += step)
                Console.WriteLine(j + 10);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you compile the code in the Release-x64 mode and run it with JIT-x64, you see the following result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optimization:
10
21
NoOptimization:
10
11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unexpectedly, is not it? JIT-x64 has played a dirty trick on us and spent optimizing crooked. Some important facts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;step&lt;/code&gt; is a method argument.&lt;/li&gt;
&lt;li&gt;Both of the loops start with zero and have the &lt;code&gt;step&lt;/code&gt; increment..&lt;/li&gt;
&lt;li&gt;&lt;code&gt;j+10&lt;/code&gt; prints on the Console, &lt;code&gt;i+10&lt;/code&gt; stores in a local variable per each first loop iteration.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These conditions (and several tricky additional conditions) allows JIT-x64 to perform an sub-expression elimination optimization. Unfortunately he does it wrong.&lt;/p&gt;
&lt;h3&gt;JIT-x86&lt;/h3&gt;
&lt;p&gt;At first, we will look to the assembler code for JIT-x86. We want to make sure that it is a code without any troubles.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;; Optimization, JIT-x86
        for (int i = 0; i &amp;lt; step; i++)                
008400DA  in          al,dx                           
008400DB  push        edi                             
008400DC  push        esi                             
008400DD  push        ebx                             
008400DE  sub         esp,8                           
008400E1  mov         dword ptr [ebp-14h],ecx         
008400E4  mov         edi,edx                         ; edi=edx (edi=step)
008400E6  xor         edx,edx                         ; edx=0
008400E8  mov         dword ptr [ebp-10h],edx         ; [ebp-10h]=edx (i=0)
008400EB  test        edi,edi                         
008400ED  jle         00840125                        
        {                                             
            bar = i + 10;                             
008400EF  mov         eax,dword ptr [ebp-10h]         ; eax=[ebp-10h] (eax=i)
008400F2  add         eax,0Ah                         ; eax+=0Ah (eax=i+10)
008400F5  mov         edx,dword ptr [ebp-14h]         ; edx=&amp;amp;this
008400F8  mov         dword ptr [edx+4],eax           ; [edx+4]=eax (bar=i+10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)  
008400FB  xor         esi,esi                         ; esi=0 (j=0)
008400FD  mov         ebx,edi                         ; ebx=edi (ebx=step)
008400FF  add         ebx,ebx                         ; ebx+=edx (ebx=2*step)
00840101  test        ebx,ebx                         
00840103  jle         0084011D                        
                Console.WriteLine(j + 10);            
00840105  call        72EE0258                        
0084010A  mov         ecx,eax                         
0084010C  lea         edx,[esi+0Ah]                   ; edx=[esi+0Ah] (edx=j+10)
0084010F  mov         eax,dword ptr [ecx]             
00840111  mov         eax,dword ptr [eax+38h]         
00840114  call        dword ptr [eax+14h]             ; Console.WriteLine(edx)
            for (int j = 0; j &amp;lt; 2 * step; j += step)  
00840117  add         esi,edi                         ; esi+=edi (j+=step)
00840119  cmp         esi,ebx                         ; if esi&amp;lt;ebx (j&amp;lt;2*step)
0084011B  jl          00840105                        ; jump to loop start (j)
        for (int i = 0; i &amp;lt; step; i++)                
0084011D  inc         dword ptr [ebp-10h]             ; [ebp-10h]++ (i++)
00840120  cmp         dword ptr [ebp-10h],edi         ; if [ebp-10h]&amp;lt;edi (i&amp;lt;step)
00840123  jl          008400EF                        ; jump to loop start (i)
00840125  lea         esp,[ebp-0Ch]                   
00840128  pop         ebx                             
00840129  pop         esi                             
0084012A  pop         edi                             
0084012B  pop         ebp                             
0084012C  ret                                         
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result is right, we can see the expected result on the Console:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optimization:
10
11
NoOptimization:
10
11
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;JIT-x64&lt;/h3&gt;
&lt;p&gt;Now, we will take the JIT-x64 assembler code and start with the &lt;code&gt;NoOptimization&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;; NoOptimization, JIT-x64
        for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC87202A5  mov         dword ptr [rsp+8],ecx    
00007FFCC87202A9  sub         rsp,38h                  
00007FFCC87202AD  mov         dword ptr [rsp+20h],0    ; [rsp+20h]=0 (i=0)
00007FFCC87202B5  mov         dword ptr [rsp+24h],0    ; [rsp+24h]=0 (j=0)
00007FFCC87202BD  mov         dword ptr [rsp+20h],0    ; [rsp+20h]=0 (i=0)
00007FFCC87202C5  jmp         00007FFCC8720316         
        {                                              
            bar = i + 10;                              
00007FFCC87202C7  mov         ecx,dword ptr [rsp+20h]  ; ecx=[rsp+20h] (ecx=i)
00007FFCC87202CB  add         ecx,0Ah                  ; ecx+=10 (ecx=i+10)
00007FFCC87202CE  mov         rax,qword ptr [rsp+40h]  ; rax=&amp;amp;this
00007FFCC87202D3  mov         dword ptr [rax+8],ecx    ; [rax+8]=ecx (bar=i+10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)   
00007FFCC87202D6  mov         dword ptr [rsp+24h],0    ; [rsp+24h]=0 (j)
00007FFCC87202DE  jmp         00007FFCC87202FC         
                Console.WriteLine(j + 10);             
00007FFCC87202E0  mov         ecx,dword ptr [rsp+24h]  ; ecx=[rsp+24h] (ecx=j)
00007FFCC87202E4  add         ecx,0Ah                  ; ecx+=10
00007FFCC87202E7  call        00007FFD273DCF10         ; Console.WriteLine(j+10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)   
00007FFCC87202EC  mov         r11d,dword ptr [rsp+48h] ; r11d=[rsp+48h] (r11d=step)
00007FFCC87202F1  mov         eax,dword ptr [rsp+24h]  ; eax=[rsp+24h] (eax=j)
00007FFCC87202F5  add         eax,r11d                 ; eax+=r11d (eax=j+step)
00007FFCC87202F8  mov         dword ptr [rsp+24h],eax  ; [rsp+24h]=eax (j=j+step)
00007FFCC87202FC  mov         eax,2                    ; eax=2
00007FFCC8720301  imul        eax,dword ptr [rsp+48h]  ; eax*=[rsp+48h] (eax=2*step)
00007FFCC8720306  cmp         dword ptr [rsp+24h],eax  ; if [resp+24h]&amp;lt;eax (j&amp;lt;2*step)
00007FFCC872030A  jl          00007FFCC87202E0         ; jump to loop start (j)
        for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC872030C  mov         eax,dword ptr [rsp+20h]  ; eax=[rsp+20h] (i)
00007FFCC8720310  inc         eax                      ; eax++ (eax=i+1)
00007FFCC8720312  mov         dword ptr [rsp+20h],eax  ; [rsp+20h]=eax (i=i+1)
00007FFCC8720316  mov         eax,dword ptr [rsp+48h]  ; eax=[rsp+48h] (eax=step)
00007FFCC872031A  cmp         dword ptr [rsp+20h],eax  ; if [rsp+20h]&amp;lt;eax (i&amp;lt;step)
00007FFCC872031E  jl          00007FFCC87202C7         ; jump to loop start (i)
        }                                              
    }                                                  
00007FFCC8720320  jmp         00007FFCC8720322         
00007FFCC8720322  nop                                  
00007FFCC8720323  add         rsp,38h                  
00007FFCC8720327  ret                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok, it is fine, go to the opimized method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;; Optimization, JIT-x64
       for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC87201C2  push        rsi                     
00007FFCC87201C3  push        rdi                     
00007FFCC87201C4  push        r12                     
00007FFCC87201C6  push        r13                     
00007FFCC87201C8  push        r14                     
00007FFCC87201CA  push        r15                     
00007FFCC87201CC  sub         rsp,28h                 
00007FFCC87201D0  mov         ebx,edx                 ; ebx=step
00007FFCC87201D2  mov         r12,rcx                 ; r12=&amp;amp;this
00007FFCC87201D5  lea         r15d,[rbx+0Ah]          ; r15d=rbx+10 (r15d=step+10)
00007FFCC87201D9  test        ebx,ebx                 
00007FFCC87201DB  jle         00007FFCC8720260        
00007FFCC87201E1  xor         esi,esi                 ; esi=0 (i=0)
00007FFCC87201E3  mov         edi,0Ah                 ; edi=10 ((i+10)=10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)  
00007FFCC87201E8  mov         ebp,2                   ; ebp=2
00007FFCC87201ED  imul        ebp,ebx                 ; ebp*=ebx (ebp=2*step)
        {                                             
            bar = i + 10;                             
00007FFCC87201F0  mov         dword ptr [r12+8],edi   ; bar=edi
            for (int j = 0; j &amp;lt; 2 * step; j += step)  
00007FFCC87201F5  test        ebp,ebp                 
00007FFCC87201F7  jle         00007FFCC8720256        
00007FFCC87201F9  xor         r13d,r13d               ; r13d=0 (j=0)
00007FFCC87201FC  mov         r14d,0Ah                ; r14d=10                     // !!!
00007FFCC8720202  nop         word ptr [rax+rax]      
00007FFCC8720210  mov         rax,0FC2B841138h        
00007FFCC872021A  mov         rax,qword ptr [rax]     
00007FFCC872021D  test        rax,rax                 
00007FFCC8720220  jne         00007FFCC8720230        
00007FFCC8720222  mov         cl,1                    
00007FFCC8720224  call        00007FFD26C0D960        
00007FFCC8720229  nop         dword ptr [rax]         
00007FFCC8720230  mov         rcx,0FC2B841138h        
00007FFCC872023A  mov         rcx,qword ptr [rcx]     
00007FFCC872023D  mov         rax,qword ptr [rcx]     
00007FFCC8720240  mov         r8,qword ptr [rax+60h]  
00007FFCC8720244  mov         edx,r14d                ; edx=r14d                     // !!!
00007FFCC8720247  call        qword ptr [r8+28h]      ; Console.WriteLine(edx)       // !!!
00007FFCC872024B  add         r13d,ebx                ; r13d+=ebx (j+=step)
00007FFCC872024E  add         r14d,r15d               ; r14d+=r15d (r14d+=(step+10)) // !!!
00007FFCC8720251  cmp         r13d,ebp                ; if r13d&amp;lt;ebp (j&amp;lt;2*step)
00007FFCC8720254  jl          00007FFCC8720210        ; jump to loop start (j)
        for (int i = 0; i &amp;lt; step; i++)                
00007FFCC8720256  inc         esi                     ; esi++ (i++)
00007FFCC8720258  inc         edi                     ; edi++ ((i+10)++)
00007FFCC872025A  cmp         esi,ebx                 ; if esi&amp;lt;ebx (i&amp;lt;step)
00007FFCC872025C  jl          00007FFCC87201F0        ; jump to loop start (i)
00007FFCC872025E  xchg        ax,ax                   
00007FFCC8720260  add         rsp,28h                 
00007FFCC8720264  pop         r15                     
00007FFCC8720266  pop         r14                     
00007FFCC8720268  pop         r13                     
00007FFCC872026A  pop         r12                     
00007FFCC872026C  pop         rdi                     
00007FFCC872026D  pop         rsi                     
00007FFCC872026E  pop         rbp                     
00007FFCC872026F  pop         rbx                     
00007FFCC8720270  ret                                 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you have some time to explore the above listing, you&#39;ll see that the problem is related with the &lt;code&gt;r14d&lt;/code&gt; register which is used for output. At the beginning of the nested loop, it is initialized by &lt;code&gt;10&lt;/code&gt;. Next, it increases by &lt;code&gt;step + 10&lt;/code&gt; on each iteration (although the increment should be equal to &lt;code&gt;step&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;There is a &lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/812093/&quot;&gt;bug report&lt;/a&gt; in MS Connect about the issue. Unfortunately, the bug status is sad:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Status: Closed as Won&#39;t Fix Won&#39;t Fix. Due to several factors the product team decided to focus its efforts on other items.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;RyuJIT&lt;/h3&gt;
&lt;p&gt;Let&#39;s download and install RyuJIT CTP5, set the &lt;code&gt;HKLM\SOFTWARE\Microsoft\.NETFramework\AltJit=&#39;*&#39;&lt;/code&gt; key in the regedit, and look to the x64 assembler code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;; Optimization, RyuJIT
        for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC86F0160  push        r14                      
00007FFCC86F0162  push        rdi                      
00007FFCC86F0163  push        rsi                      
00007FFCC86F0164  push        rbp                      
00007FFCC86F0165  push        rbx                      
00007FFCC86F0166  sub         rsp,20h                  
00007FFCC86F016A  mov         rdi,rcx                  ; rdi=&amp;amp;this
00007FFCC86F016D  mov         esi,edx                  ; esi=edx (esi=step)
00007FFCC86F016F  xor         ebx,ebx                  ; ebx=0 (i=0)
00007FFCC86F0171  test        esi,esi                  
00007FFCC86F0173  jle         00007FFCC86F01AA         
00007FFCC86F0175  mov         ebp,esi                  ; ebp=esi (ebp=step)
00007FFCC86F0177  shl         ebp,1                    ; ebp*=2 (ebp=2*step)
        {                                              
            bar = i + 10;                              
00007FFCC86F0179  lea         eax,[rbx+0Ah]            ; eax=[rbx+0Ah] (eax=i+10)
00007FFCC86F017C  mov         dword ptr [rdi+8],eax    ; [rdi+8]=eax (bar=i+10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)   
00007FFCC86F017F  xor         r14d,r14d                ; r14d=0 (j=0)
00007FFCC86F0182  test        ebp,ebp                  
00007FFCC86F0184  jle         00007FFCC86F01A4         
                Console.WriteLine(j + 10);             
00007FFCC86F0186  call        00007FFD26C0AFA0         
00007FFCC86F018B  mov         rcx,rax                  
00007FFCC86F018E  lea         edx,[r14+0Ah]            ; edx=r14+0Ah (edx=j+10)
00007FFCC86F0192  mov         rax,qword ptr [rax]      
00007FFCC86F0195  mov         rax,qword ptr [rax+60h]  
00007FFCC86F0199  call        qword ptr [rax+28h]      ; Console.WriteLine(edx)
            for (int j = 0; j &amp;lt; 2 * step; j += step)   
00007FFCC86F019C  add         r14d,esi                 ; r14d+=esi (j+=step)
00007FFCC86F019F  cmp         r14d,ebp                 ; if (r14d&amp;lt;ebp) (j&amp;lt;2*step)
00007FFCC86F01A2  jl          00007FFCC86F0186         ; jump to loop start (j)
        for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC86F01A4  inc         ebx                      ; ebx++ (i++)
00007FFCC86F01A6  cmp         ebx,esi                  ; if ebx&amp;lt;esi (i&amp;lt;step)
00007FFCC86F01A8  jl          00007FFCC86F0179         ; jump to loop start (i)
00007FFCC86F01AA  add         rsp,20h                  
00007FFCC86F01AE  pop         rbx                      
00007FFCC86F01AF  pop         rbp                      
00007FFCC86F01B0  pop         rsi                      
00007FFCC86F01B1  pop         rdi                      
00007FFCC86F01B2  pop         r14                      
00007FFCC86F01B4  ret                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everything is fine: clever optimization are absent, the code works correctly.&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;The JIT-x86 and RyuJIT CTP5 don&#39;t have the described bug. However, it is exist in JIT-x64. Most likely, it will not going anywhere.&lt;/p&gt;
&lt;p&gt;You should understand, there is no perfect software. .NET is not an exception. Bugs in the JIT are extremely rare, but it is useful to bear in mind that thay may exist.&lt;/p&gt;
&lt;h3&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/20701701/jit-net-compiler-bug&quot;&gt;StackOverflow: JIT .Net compiler bug?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/812093/x64-jitter-sub-expression-elimination-optimizer-bug&quot;&gt;MS Connect: x64 jitter sub-expression elimination optimizer bug&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dotnet/inlining-and-starg/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dotnet/inlining-and-starg/'/>
              <title>A story about JIT-x86 inlining and starg</title>
              <updated>2015-02-26T00:00:00Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;Sometimes you can learn a lot during reading source .NET. Let&#39;s open the source code of a &lt;code&gt;Decimal&lt;/code&gt; constructor from .NET Reference Source (&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/decimal.cs,158&quot;&gt;mscorlib/system/decimal.cs,158&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Constructs a Decimal from an integer value.
//
public Decimal(int value) {
    //  JIT today can&#39;t inline methods that contains &amp;quot;starg&amp;quot; opcode.
    //  For more details, see DevDiv Bugs 81184: x86 JIT CQ: Removing the inline striction of &amp;quot;starg&amp;quot;.
    int value_copy = value;
    if (value_copy &amp;gt;= 0) {
        flags = 0;
    }
    else {
        flags = SignMask;
        value_copy = -value_copy;
    }
    lo = value_copy;
    mid = 0;
    hi = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The comment states that JIT-x86 can&#39;t apply the inlining optimization for a method that contains the &lt;a href=&quot;https://msdn.microsoft.com/library/system.reflection.emit.opcodes.starg.aspx&quot;&gt;starg&lt;/a&gt; IL-opcode. Curious, is not it? &lt;!--more--&gt;&lt;/p&gt;
&lt;h3&gt;The JIT sources&lt;/h3&gt;
&lt;p&gt;Let&#39;s examine the situation and open the JIT source codes from CoreCLR. The fragment of &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/flowgraph.cpp#L4252&quot;&gt;flowgraph.cpp&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// NetCF had some strict restrictions on inlining.  Specifically they
// would only inline methods that fit a specific pattern of loading
// arguments inorder, starting with zero, with no skipping, but not
// needing to load all of them.  Then a &#39;body&#39; section that could do
// anything besides control flow.  And a final ending ret opcode.
// Lastly they did not allow starg or ldarga.
// These simplifications allowed them to skip past the ldargs, when
// inlining, and just use the caller&#39;s EE stack as the callee&#39;s EE
// stack, after optionally popping a few &#39;arguments&#39; from the end.
//
// stateNetCFQuirks is a simple state machine to track that state
// and allow us to match those restrictions.
// State -1 means we&#39;re not tracking (no quirks mode)
// State 0 though 0x0000FFFF tracks what the *next* ldarg should be
//    to match the pattern
// State 0x00010000 and above means we are in the &#39;body&#39; section and
//    thus no more ldarg&#39;s are allowed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It states that inlining can&#39;t be applied for a method with opcodes &lt;code&gt;starg&lt;/code&gt; or &lt;code&gt;ldarga&lt;/code&gt;. Let&#39;s read the below code and make sure that this is true:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;switch (opcode)

// ...

    case CEE_STARG:
    case CEE_STARG_S:     goto ARG_WRITE;

    case CEE_LDARGA:
    case CEE_LDARGA_S:
    case CEE_LDLOCA:
    case CEE_LDLOCA_S:    goto ADDR_TAKEN;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;starg&lt;/code&gt; case is the simplest, let&#39;s look to the corresponding code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;ARG_WRITE:
            if (compIsForInlining())
            {

#ifdef DEBUG
                if (verbose)
                {
                    printf(&amp;quot;\n\nInline expansion aborted due to opcode at offset [%02u] which writes to an argument\n&amp;quot;,
                           codeAddr-codeBegp-1);
                }
#endif

                /* The inliner keeps the args as trees and clones them.  Storing the arguments breaks that
                 * simplification.  To allow this, flag the argument as written to and spill it before
                 * inlining.  That way the STARG in the inlinee is trivial. */
                inlineFailReason = &amp;quot;Inlinee writes to an argument.&amp;quot;;
                goto InlineNever;
            }
            else
            {
                noway_assert(sz == sizeof(BYTE) || sz == sizeof(WORD));
                if (codeAddr &amp;gt; codeEndp - sz)
                goto TOO_FAR;
                varNum = (sz == sizeof(BYTE)) ? getU1LittleEndian(codeAddr)
                                              : getU2LittleEndian(codeAddr);
                varNum = compMapILargNum(varNum); // account for possible hidden param

                // This check is only intended to prevent an AV.  Bad varNum values will later
                // be handled properly by the verifier.
                if (varNum &amp;lt; lvaTableCnt)
                    lvaTable[varNum].lvArgWrite = 1;
            }
            break;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, for the &lt;code&gt;starg&lt;/code&gt; case, &lt;code&gt;goto InlineNever&lt;/code&gt; will be executed. In the &lt;code&gt;Debug&lt;/code&gt; moode, you also receive a message about aborted inlining.&lt;/p&gt;
&lt;p&gt;This “feature” uses in other JIT source files. Let&#39;s open the following fragment from &lt;a href=&quot;https://raw.githubusercontent.com/dotnet/coreclr/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/importer.cpp&quot;&gt;importer.cpp&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;/******************************************************************************
 Is this the original &amp;quot;this&amp;quot; argument to the call being inlined?
 
 Note that we do not inline methods with &amp;quot;starg 0&amp;quot;, and so we do not need to
 worry about it.
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Look to the  Decimal&lt;/h3&gt;
&lt;p&gt;Let&#39;s go back to the &lt;code&gt;Decimal&lt;/code&gt; constructor and make sure that coping the &lt;code&gt;value&lt;/code&gt; argument to a local variable really helps. We will use &lt;a href=&quot;http://ilspy.net/&quot;&gt;ILSpy&lt;/a&gt; for examination of the source constructor IL code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Methods
.method public hidebysig specialname rtspecialname 
  instance void .ctor (
    int32 &#39;value&#39;
  ) cil managed 
{
  .custom instance void __DynamicallyInvokableAttribute::.ctor() = (
    01 00 00 00
  )
  // Method begins at RVA 0x222e8
  // Code size 51 (0x33)
  .maxstack 2
  .locals init (
    [0] int32
  )

  IL_0000: ldarg.1
  IL_0001: stloc.0
  IL_0002: ldloc.0
  IL_0003: ldc.i4.0
  IL_0004: blt.s IL_000f

  IL_0006: ldarg.0
  IL_0007: ldc.i4.0
  IL_0008: stfld int32 System.Decimal::&#39;flags&#39;
  IL_000d: br.s IL_001d

  IL_000f: ldarg.0
  IL_0010: ldc.i4 -2147483648
  IL_0015: stfld int32 System.Decimal::&#39;flags&#39;
  IL_001a: ldloc.0
  IL_001b: neg
  IL_001c: stloc.0

  IL_001d: ldarg.0
  IL_001e: ldloc.0
  IL_001f: stfld int32 System.Decimal::lo
  IL_0024: ldarg.0
  IL_0025: ldc.i4.0
  IL_0026: stfld int32 System.Decimal::mid
  IL_002b: ldarg.0
  IL_002c: ldc.i4.0
  IL_002d: stfld int32 System.Decimal::hi
  IL_0032: ret
} // end of method Decimal::.ctor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What would have happened if we had not copied the &lt;code&gt;value&lt;/code&gt; in a local variable? Let&#39;s check. Write a simple code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;class MyDecimal
{
  private const int SignMask  = unchecked((int)0x80000000);
  private int flags, hi, lo, mid;

  public MyDecimal(int value)
  {
    if (value &amp;gt;= 0) {
        flags = 0;
    }
    else {
        flags = SignMask;
        value = -value;
    }
    lo = value;
    mid = 0;
    hi = 0;
  }
}
class Program
{
  static void Main()
  {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compilation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;csc Program.cs /optimize
Microsoft (R) Visual C# Compiler version 4.0.30319.33440
for Microsoft (R) .NET Framework 4.5
Copyright (C) Microsoft Corporation. All rights reserved.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The resulted IL:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.class private auto ansi beforefieldinit MyDecimal
  extends [mscorlib]System.Object
{
  // Fields
  .field private static literal int32 SignMask = int32(-2147483648)
  .field private int32 &#39;flags&#39;
  .field private int32 hi
  .field private int32 lo
  .field private int32 mid

  // Methods
  .method public hidebysig specialname rtspecialname 
    instance void .ctor (
      int32 &#39;value&#39;
    ) cil managed 
  {
    // Method begins at RVA 0x2050
    // Code size 56 (0x38)
    .maxstack 8

    IL_0000: ldarg.0
    IL_0001: call instance void [mscorlib]System.Object::.ctor()
    IL_0006: ldarg.1
    IL_0007: ldc.i4.0
    IL_0008: blt.s IL_0013

    IL_000a: ldarg.0
    IL_000b: ldc.i4.0
    IL_000c: stfld int32 MyDecimal::&#39;flags&#39;
    IL_0011: br.s IL_0022

    IL_0013: ldarg.0
    IL_0014: ldc.i4 -2147483648
    IL_0019: stfld int32 MyDecimal::&#39;flags&#39;
    IL_001e: ldarg.1
    IL_001f: neg
    IL_0020: starg.s &#39;value&#39;

    IL_0022: ldarg.0
    IL_0023: ldarg.1
    IL_0024: stfld int32 MyDecimal::lo
    IL_0029: ldarg.0
    IL_002a: ldc.i4.0
    IL_002b: stfld int32 MyDecimal::mid
    IL_0030: ldarg.0
    IL_0031: ldc.i4.0
    IL_0032: stfld int32 MyDecimal::hi
    IL_0037: ret
  } // end of method MyDecimal::.ctor

} // end of class MyDecimal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, in the line &lt;code&gt;IL_0020&lt;/code&gt;, the &lt;code&gt;starg.a&lt;/code&gt; opcode appears. Authors of the .NET framework use the same approach for the &lt;code&gt;Decimal&lt;/code&gt; constructor with the &lt;code&gt;long&lt;/code&gt; argument:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Constructs a Decimal from a long value.
//
public Decimal(long value) {
    //  JIT today can&#39;t inline methods that contains &amp;quot;starg&amp;quot; opcode.
    //  For more details, see DevDiv Bugs 81184: x86 JIT CQ: Removing the inline striction of &amp;quot;starg&amp;quot;.
    long value_copy = value;
    if (value_copy &amp;gt;= 0) {
        flags = 0;
    }
    else {
        flags = SignMask;
        value_copy = -value_copy;
    }
    lo = (int)value_copy;
    mid = (int)(value_copy &amp;gt;&amp;gt; 32);
    hi = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Check the JIT possibilities&lt;/h3&gt;
&lt;p&gt;Now, we want to make sure that JIT really have the described behavior. Let&#39;s write the simple code for checking:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Runtime.CompilerServices;

class Program
{
    static void Main()
    {
        var value = 0;
        value += SimpleMethod(0x11);
        value += MethodWithStarg(0x12);
        value += MethodWithStargAggressive(0x13);
        Console.WriteLine(value);
    }

    static int SimpleMethod(int value)
    {
        return value;
    }

    static int MethodWithStarg(int value)
    {
        if (value &amp;lt; 0)
            value = -value;
        return value;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static int MethodWithStargAggressive(int value)
    {
        if (value &amp;lt; 0)
            value = -value;
        return value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;SimpleMethod&lt;/code&gt; method is very small, it will be inlined. The &lt;code&gt;MethodWithStarg&lt;/code&gt; method has the following IL-representation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;.method private hidebysig static 
  int32 MethodWithStarg (
    int32 &#39;value&#39;
  ) cil managed 
{
  // Method begins at RVA 0x2086
  // Code size 10 (0xa)
  .maxstack 8

  IL_0000: ldarg.0
  IL_0001: ldc.i4.0
  IL_0002: bge.s IL_0008

  IL_0004: ldarg.0
  IL_0005: neg
  IL_0006: starg.s &#39;value&#39;

  IL_0008: ldarg.0
  IL_0009: ret
} // end of method Program::MethodWithStarg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the &lt;code&gt;IL_0006&lt;/code&gt; line, this code contains the target &lt;code&gt;starg.s&lt;/code&gt; opcode. The &lt;code&gt;MethodWithStargAggressive&lt;/code&gt; method have the same body, but it also has the &lt;code&gt;[MethodImpl(MethodImplOptions.AggressiveInlining)]&lt;/code&gt; attribute. Let&#39;s look to the assembler code for x86:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;008A0050  push        ebp  
008A0051  mov         ebp,esp  
008A0053  push        esi  
008A0054  mov         ecx,12h  
008A0059  call        dword ptr ds:[7237BCh]  // MethodWithStarg
008A005F  add         eax,11h  
008A0062  mov         esi,eax  
008A0064  mov         ecx,13h  
008A0069  call        dword ptr ds:[7237C8h]  // MethodWithStargAggressive
008A006F  add         esi,eax  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The experiment was a success. &lt;code&gt;SimpleMethod&lt;/code&gt; was inlined as we expected. &lt;code&gt;MethodWithStarg&lt;/code&gt; wasn&#39;t be inlined because it contains the &lt;code&gt;starg.s&lt;/code&gt; opcode. Note, &lt;code&gt;[MethodImpl(MethodImplOptions.AggressiveInlining)]&lt;/code&gt; didn&#39;t help to &lt;code&gt;MethodWithStargAggressive&lt;/code&gt; inlining.&lt;/p&gt;
&lt;p&gt;Now we will look to the assembler code for x64:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00007FFCC8720094  mov         ecx,36h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, JIT has successfully performed inlining for all method and precalculated the result.&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;Specific condition should be satisfied for successfully inlining. JIT-x86 can&#39;t apply the inlining optimization for method that contain the &lt;code&gt;starg&lt;/code&gt; or&lt;code&gt;ldarga&lt;/code&gt; opcodes regardless the &lt;code&gt;MethodImpl&lt;/code&gt; attribute. Sometimes, if you really need inlining of some method, you have to make some hacks like we can observe in the &lt;code&gt;Decimal&lt;/code&gt; constructors.&lt;/p&gt;
&lt;h3&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/decimal.cs,158&quot;&gt;.NET Reference Source: Constructs a Decimal from an integer value&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/flowgraph.cpp#L4252&quot;&gt;CoreCLR, JIT sources: flowgraph.cpp (Feb 26, 2015)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://raw.githubusercontent.com/dotnet/coreclr/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/importer.cpp&quot;&gt;CoreCLR, JIT sources: importer.cpp (Feb 26, 2015)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.reflection.emit.opcodes.starg.aspx&quot;&gt;MSDN: starg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.reflection.emit.opcodes.ldarga.aspx&quot;&gt;MSDN: ldarga&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/26369163/net-local-variable-optimization&quot;&gt;Stackoverflow: .NET local variable optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dotnet/mono-utf8-conversions/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dotnet/mono-utf8-conversions/'/>
              <title>About UTF-8 conversions in Mono</title>
              <updated>2014-11-10T00:03:00Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;This post is a logical continuation of the Jon Skeet&#39;s blog post &lt;a href=&quot;http://codeblog.jonskeet.uk/2014/11/07/when-is-a-string-not-a-string&quot;&gt;“When is a string not a string?”&lt;/a&gt;. Jon showed very interesting things about behavior of ill-formed Unicode strings in .NET. I wondered about how similar examples will work on Mono. And I have got very interesting results.&lt;/p&gt;
&lt;h3&gt;Experiment 1: Compilation&lt;/h3&gt;
&lt;p&gt;Let&#39;s take the Jon&#39;s code with a small modification. We will just add &lt;code&gt;text&lt;/code&gt; null check in &lt;code&gt;DumpString&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.ComponentModel;
using System.Text;
using System.Linq;
 
[Description(Value)]
class Test
{
    const string Value = &amp;quot;X\ud800Y&amp;quot;;
 
    static void Main()
    {
        var description = (DescriptionAttribute)typeof(Test).
            GetCustomAttributes(typeof(DescriptionAttribute), true)[0];
        DumpString(&amp;quot;Attribute&amp;quot;, description.Description);
        DumpString(&amp;quot;Constant&amp;quot;, Value);
    }
 
    static void DumpString(string name, string text)
    {
        Console.Write(&amp;quot;{0}: &amp;quot;, name);
        if (text != null)
        {
            var utf16 = text.Select(c =&amp;gt; ((uint) c).ToString(&amp;quot;x4&amp;quot;));
            Console.WriteLine(string.Join(&amp;quot; &amp;quot;, utf16));
        }
        else
            Console.WriteLine(&amp;quot;null&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Let&#39;s compile the code with MS.NET (csc) and Mono (mcs). The resulting IL files will have one important distinction:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET compiler
.custom instance void class
[System]System.ComponentModel.DescriptionAttribute::&#39;.ctor&#39;(string) =
(01 00 05 58 ED A0 80 59 00 00 ) // ...X...Y..
// Mono compiler
.custom instance void class
[System]System.ComponentModel.DescriptionAttribute::&#39;.ctor&#39;(string) =
(01 00 05 58 59 BF BD 00 00 00 ) // ...XY.....
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 1:&lt;/strong&gt; MS.NET and Mono transform original C# strings to UTF-8 IL strings in different ways. But both ways give non-valid UTF-8 strings (&lt;code&gt;58 ED A0 80 59&lt;/code&gt; and &lt;code&gt;58 59 BF BD 00&lt;/code&gt;).&lt;/p&gt;
&lt;h3&gt;Experiment 2: Run&lt;/h3&gt;
&lt;p&gt;Ok, let&#39;s run it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET compiler / MS.NET runtime
Attribute: 0058 fffd fffd 0059
Constant: 0058 d800 0059
// MS.NET compiler / Mono runtime
Attribute: null
Constant: 0058 d800 0059
// Mono compiler / MS.NET runtime
Attribute: 0058 0059 fffd fffd 0000
Constant: 0058 d800 0059
// Mono compiler / Mono runtime
Attribute: null
Constant: 0058 d800 0059
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 2:&lt;/strong&gt; Mono runtime can&#39;t use our non-valid UTF-8 IL strings. Instead, Mono use &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Experiment 3: Manual UTF-8 to String conversion&lt;/h3&gt;
&lt;p&gt;Ok, but what if we create non-valid UTF-8 string in runtime? Let&#39;s check it! The code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Text;
using System.Linq;

class Test
{
    static void Main()
    {
        DumpString(&amp;quot;(1)&amp;quot;, Encoding.UTF8.GetString(
            new byte[] { 0x58, 0xED, 0xA0, 0x80, 0x59 }));
        DumpString(&amp;quot;(2)&amp;quot;, Encoding.UTF8.GetString(
            new byte[] { 0x58, 0x59, 0xBF, 0xBD, 0x00 }));
    }

    static void DumpString(string name, string text)
    {
        Console.Write(&amp;quot;{0}: &amp;quot;, name);
        if (text != null)
        {
            var utf16 = text.Select(c =&amp;gt; ((uint)c).ToString(&amp;quot;x4&amp;quot;));
            Console.WriteLine(string.Join(&amp;quot; &amp;quot;, utf16));
        }
        else
            Console.WriteLine(&amp;quot;null&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET runtime
(1): 0058 fffd fffd 0059
(2): 0058 0059 fffd fffd 0000
// Mono runtime
(1): 0058 fffd fffd fffd 0059
(2): 0058 0059 fffd fffd 0000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MS.NET and Mono implement UTF-8 to String conversion in different ways. The &lt;code&gt;ED A0 80&lt;/code&gt; sequence transforms to &lt;code&gt;FFDD FFDD&lt;/code&gt; on MS.NET and to &lt;code&gt;FFDD FFDD FFDD&lt;/code&gt; on Mono.&lt;/p&gt;
&lt;h3&gt;Experiment 4: Manual String to UTF-8 conversion&lt;/h3&gt;
&lt;p&gt;Let&#39;s look to the reverse conversion (from String to UTF-8). The code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var bytes = Encoding.UTF8.GetBytes(&amp;quot;X\ud800Y&amp;quot;);
Console.WriteLine(string.Join(&amp;quot; &amp;quot;, bytes.Select(b =&amp;gt; b.ToString(&amp;quot;x2&amp;quot;))));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET runtime
58 ef bf bd 59
// Mono runtime
58 59 bf bd 00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 4:&lt;/strong&gt; MS.NET and Mono implement String to UTF-8 conversion in different ways too.&lt;/p&gt;
&lt;h3&gt;Experiment 5: Prohibition of ill-formed string&lt;/h3&gt;
&lt;p&gt;Also, Jon&#39;s has written about prohibition of ill-formed strings in some attributes. For example, the code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[DllImport(Value)]
static extern void Foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will not compile on csc or Roslyn. But it will be successfully compile on Mono!&lt;/p&gt;
&lt;p&gt;Another example: the code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Conditional(Value)]
void Bar() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will not compile on csc and Mono:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET compiler
error CS0647:
Error emitting ‘DllImportAttribute’ attribute
// Mono compiler
error CS0633:
The argument to the ‘ConditionalAttribute’ attribute must be a valid identifier
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Encodings are hard.&lt;/p&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dev/refactoring/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dev/refactoring/'/>
              <title>To Refactor Or Not To Refactor?</title>
              <updated>2014-07-19T08:59:00.001Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;I like refactoring. No, I love refactoring. No, not even like this. I awfully love refactoring.&lt;/p&gt;
&lt;p&gt;I hate bad code and bad architecture. I feel quite creepy when I design a new feature and the near-by class contains absolute mess. I just can’t look at the sadly-looking variables. Sometimes before falling asleep I close my eyes and imagine what could be improved in the project. Sometimes I wake up at 3:00AM and go to my computer to improve something. I want to have not just code, but a masterpiece that is pleasant to look at, that is pleasant to work with at any stage of the project.&lt;/p&gt;
&lt;p&gt;If you just a little bit share my feelings we have something to talk about. The matter is that over some time something inside me began to hint that it’s a bad idea to refactor all code, everywhere and all the time. Understand me correctly – code should be good (even better when it’s ideal), but in real life it’s not reasonable to improve code instantly. I formed some rules about the refactoring timeliness. If I am itching to improve something, I look at these rules and think “Is that the moment when I need to refactor the code?” So, let’s talk about when refactoring is necessary and when it’s inappropriate.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Disclaimer:&lt;/em&gt; Most likely many of you will immediately say: “We have discussed it 60 times!” or “This is so obvious, why writing about it?” Probably, you’re right, but there is one moment: there is chaos all around. It looks like everything is clear, but in fact it’s not that clear at all. That is why I think it won’t be much harm to have another look at this issue. If you have no problems with refactoring you can just miss this post, everything is already ok for you.&lt;/p&gt;
&lt;h3&gt;Too early refactoring&lt;/h3&gt;
&lt;p&gt;Do you remember when you had a permanent project specification that hasn’t been changed for months? I can hardly remember such a situation. We live in real world, requirements constantly change. And it’s not always about external requirements; it can be about your own requirements to the project. Here is the sample: let’s assume you got a mid-sized task for one or two days. Some classes have been created, but there is nothing to run yet – you create harsh architectural part. And here you notice that one of the parts is not very universal: “What if we need to do X in six months, everyone will suffer”. It’s understandable that you don’t want to commit bad code to the repository to make other developers apply harsh epithets to you. And you start refactoring the unfinished feature. Sometimes it’s reasonable, but there should be a “DANGER” label on this way. You will fix one issue, then another one, then one more issue. A week has passed, the feature still can’t run, but you say: “It’s all done inappropriately. Now I really know how I need to do it. I will re-write everything from scratch.” The main problem is that you have no feedback on the feature and you have already started improving code base. Such approach will hardly bring much success. I don’t know how it is about you, I often begin to understand that the feature should work a bit differently right after it’s been finished. And this is not because I am so stupid and couldn’t think it over properly. You need to touch some functionality to understand how it should be done in the release version. Sometimes a small prototype (allowing bad code and bugs) is necessary to discuss the feature with colleagues. Sometimes you need to show a thing to the customer to get his feedback: “No, I didn’t want it in this way, you need to do it in the opposite way”. Users don’t like innovations, they want everything as it was before. The problem with new features is that it’s difficult to predict their future. Very often all practical work goes to trash because the team decided to do it in a different way after some discussions. Summary: don’t refactor too early especially if you are not sure your code will stay in the project.&lt;/p&gt;
&lt;h3&gt;Off purpose refactoring&lt;/h3&gt;
&lt;p&gt;Most likely you have development plan for the nearest future. Most likely there is the deadline (even if you set it). Projects should be released in time, don’t delay it. You need to control yourself, you need to do the things that are within your direct purposes. Assume, you’ve got code snippet that looks like… Looks awfully. And you don’t work with this code at the moment. This code works stably, does the job successfully and is not connected to your current task. So, don’t touch it! Yes, you can feel sad that the other part of the project isn’t that good. But notice that it doesn’t affect you in any way. You have current tasks, work on them. Of course, there are tasks to improve code base; but very often it’s usually more important to add new features or fix bugs. Focus on your current tasks and don’t delay them because something is wrong somewhere.&lt;/p&gt;
&lt;h3&gt;Refactoring for refactoring&lt;/h3&gt;
&lt;p&gt;Ok, you came to conclusion that you certainly need to refactor some part of your project. Well, let’s refactor. It seems that all planned modifications are done and here you get an idea: “What else can be improved? Here is the thing.” And there obviously will be another thing and then another, and one more thing, etc. It’s necessary to understand that there is bad code, good code and ideal code. The last one will never be available in a big project. It doesn’t mean that you don’t need to achieve it, but you need to understand its inaccessibility. Usually the task is to write good code, not ideal. Assume that after refactoring, you got quite understandable code that works in an obvious manner, that doesn’t contain kludges and that is quite easy-to-use. Ask yourself: “May it’s time to stop?” Yes, you can continue improving the code. And you can do it infinitely in a quite big project. But right now it does the job, it’s convenient to use, it almost doesn’t annoy you. It’s very important to determine acceptable quality of code that prevents you from further improvement (until its acceptability is lost). Remember that there are so many cool things that you can create. Don’t refactor for refactoring, for ideal code. It’s necessary to refactor when you have solid reasons: the code is unreadable, it’s difficult to maintain, develop and use. If none of these reasons appear, you don’t need refactoring.&lt;/p&gt;
&lt;h3&gt;A-day-before-release refactoring&lt;/h3&gt;
&lt;p&gt;It happens that the release should be delivered today/ tomorrow/the day after tomorrow (underline the applicable variant). This is an important moment in the project life cycle. Developers need to spend time for testing, fixing of critical bugs, finishing work. Believe me, this is a really bad idea to refactor code base (and it’s even worse – do it qualitatively) when you need to provide code to production. My experience says that it’s better to release the project and then improve code with no mess. Some developers can ask: “Why?” If there is such a question you probably have never done complicated refactoring. I will give you a hint: when you improve the code, it’s not necessarily improved – sometimes it can break. It’s not always about complicated refactoring. Sometimes you just fix a single method of five lines, miss some dependency and the other part of project gets critical bug that your users immediately face with. It seems that you don’t do anything wrong and here you are attacked by the beast called “It was obvious” and it drowns you in the pond of improper initial estimation. Though may be I am a bad developer – I like to break something. It’s possible that you always refactor in an absolutely right manner and with due control of the whole project. In this case I can congratulate you, but I won’t refuse my advice about pre-release refactoring. Believe me, refactoring won’t run away in several days and the entire team will sleep a little bit better.&lt;/p&gt;
&lt;h3&gt;Refactoring of the very old code&lt;/h3&gt;
&lt;p&gt;The question is difficult, very difficult. The situation is as follows: there is an enormous amount of code lines that you’ve got from the previous developers (probably, this previous developer was you several years ago before you got to know how to write the correct code at once). Code should be maintained. Here and there developers add kludges and duplicates; entropy increases. Day by day you even more and more want to throw everything away and start from the very beginning. At this moment you need to think carefully about all risks. Yes, it’s possible that this activity will be helpful in the future. But in what future? and how much helpful? Most likely in the process of big refactoring or re-writing of separate parts, you will replace the old working bad code with new ideal code, yet with bugs. And this is not because you are a bad programmer and write bad code. It’s just about the fact that you may not know this code enough. You may not know why the author projected everything in this manner, and there could be some reasons. Sometimes you have to write a very rear and awkward code. I can give a lot of samples: suppression of tricky processor optimizations; adjustment to the bugs of some third party library, suppression of some multi-threaded issues, etc. I don’t say that you can’t solve these issues properly. Sometimes when you replace the absurd code with the good one, you get lots of bugs. Yes, you could do it properly, but you might not realize the entire splendor of the hut of kludges instead of sticks, if you don’t ask author of this code why it’s written in this way (and this is quite a rare opportunity). Be careful when you re-write the old code that you don’t completely understand (and especially when you think there is nothing to understand).&lt;/p&gt;
&lt;h3&gt;So, when to refactor?&lt;/h3&gt;
&lt;p&gt;I am sorry if the first part of this article made you think that refactoring only brings problems. I still insist that the code should be readable and understandable. It also should be convenient to use and easy to maintain and develop. Positive approach is better than the negative one. So, think of refactoring not as of the source of problems, but as of your good friend who will come to rescue in an hour of need. Moreover, this friend can reduce the amount of such hours in your promising future. I would like to indicate several moments when refactoring is really relevant.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Nothing to do.&lt;/strong&gt; Sometimes there happens project downtime when all critical tasks are closed and the new ones haven’t been set yet. It’s not really that there is nothing to do at all, but you have some free time. Spend it to improve the code. Give understandable names to substances, get rid of duplicates, re-write inaccurate architecture. Though no new features are added, you make contribution to peace of mind of developers who will continue working in the project. Believe me, this is very important.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Everyday pain.&lt;/strong&gt; It happens that there is a part of the project that makes you sigh every day. And you hear similar sighs of your colleagues from the nearby working places. Of course, the release date is not tomorrow, but there are lots of important tasks. Nevertheless, week passes by week and it becomes more and more disappointing to see this code. Say: “This is enough!” If the business plan is created by your chief then you need to explain that this code just should be re-designed. If you have a customer, convince him that a week spent for refactoring will save much time in the future. If you work for users, make the decision that this time it would be better for the users to wait for a new version for one more week and then enjoy stable software and regular updates. Yes, it’s not that easy to agree with the others and with yourself, but do your best.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;The problem of late refactoring.&lt;/strong&gt; Don’t overemphasize the rule of early refactoring. Some developers think: “Now I will improve something and it won’t come useful – that’s a shame.” You need to understand that the application engine can contain critical parts that would better be written properly. Remember that the later you make refactoring the higher will be its cost because you will spend more time and effort for re-writing. Critical base code (that is used throughout the project) should constantly be in a good condition. It would be great for your team to have the following statement work: “Refactoring never comes late. It comes exclusively when it thinks it’s necessary.”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Meeting with a monster.&lt;/strong&gt; You begin to add new features that should use the old project part which looks like a real monster: you’re scared only at a glance on the external interface. If you have enough time it would be better to fix code base and then focus on the new functions and don’t get distracted to add some kludges for code re-use.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reasonable perfectionism.&lt;/strong&gt; Have you noticed bad code? Want to fix it? Really want to fix it? If you really want it, do it. But pay attention to the word “reasonable”. Correlate time spent for refactoring to benefits you get from code improvement. Don’t postpone the deadline and don’t go deep into infinite improving of the code. Though if you refactor timely and reasonably, the project will succeed.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;All the above is a personal summary of experience related to the work on some projects. Of course, I haven’t covered all situations. Every team has its own requirements to the code, its own business plan and its rules. I am sure many developers have a couple of stories like: “And there was a case when all the advice doesn’t work”. This is absolutely ok, it should be like this. There is no silver bullet to define the amount of effort for code optimization (like “We will refactor every day for 47 minutes and 23 seconds and everything will be ok”). In your certain team, in every certain project and based on your personal experience, you need to find the golden mean between adding the new code and improving the old code. I agitate for reasonable approach to everything, without fanaticism (“Why improve the code, no new functions will appear” / “I need to make all code ideal, so it will be fine to work with.”). Be wise when allocating time for the work with the existing code and everything will be ok for you.&lt;/p&gt;
&lt;p&gt;You’re welcome with ideas and thoughts on when it’s ok or not ok to refactor. One of the most valuable things in the field is experience of real developers who work with real projects.&lt;/p&gt;
&lt;h2&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/to-refactor-or-not-to-refactor-part-i/&quot;&gt;blogs.perpetuumsoft.com, Part I&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/to-refactor-or-not-to-refactor-part-ii/&quot;&gt;blogs.perpetuumsoft.com, Part II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dotnet/findelementsinhostcoordinates/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dotnet/findelementsinhostcoordinates/'/>
              <title>Strange behavior of FindElementsInHostCoordinates in WinRT</title>
              <updated>2014-04-29T10:24:00.001Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;Silverlight features a splendid method: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.windows.media.visualtreehelper.findelementsinhostcoordinates(v=vs.95).aspx&quot;&gt;VisualTreeHelper.FindElementsInHostCoordinates&lt;/a&gt;. It allows the &lt;code&gt;HitTest&lt;/code&gt;, i.e. makes it possible for a point or rectangle to search for all visual sub-tree objects that intersect this rectangle or point. Formally the same method &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.visualtreehelper.findelementsinhostcoordinates.aspx&quot;&gt;VisualTreeHelper.FindElementsInHostCoordinates&lt;/a&gt; is available in WinRT. And it seems the method looks in the same way, but there is a little nuance. It works differently in different versions of the platform. So, let’s see what’s going on.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Let’s create a simple Silverlight 5 application. The markup will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Grid x:Name=&amp;quot;LayoutRoot&amp;quot;&amp;gt;
  &amp;lt;Grid.RowDefinitions&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;*&amp;quot;/&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;100&amp;quot;/&amp;gt;
  &amp;lt;/Grid.RowDefinitions&amp;gt;

  &amp;lt;Canvas MouseLeftButtonDown=&amp;quot;OnMainCanvasMouseLeftButtonDown&amp;quot; 
          x:Name=&amp;quot;MainCanvas&amp;quot; Background=&amp;quot;LightGreen&amp;quot;&amp;gt;
    &amp;lt;Ellipse Width=&amp;quot;200&amp;quot; Height=&amp;quot;200&amp;quot; Fill=&amp;quot;LightCoral&amp;quot; /&amp;gt;
    &amp;lt;Path Fill=&amp;quot;LightBlue&amp;quot; Data=&amp;quot;M 10,100 C 10,300 300,-200 300,100&amp;quot;/&amp;gt;
  &amp;lt;/Canvas&amp;gt;

  &amp;lt;TextBlock Grid.Row=&amp;quot;1&amp;quot; x:Name=&amp;quot;StatusBlock&amp;quot; /&amp;gt;
&amp;lt;/Grid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s very simple: we have a &lt;code&gt;Canvas&lt;/code&gt;, an &lt;code&gt;Ellipse&lt;/code&gt; and a &lt;code&gt;Path&lt;/code&gt; are on the Canvas. A &lt;code&gt;TextBlock&lt;/code&gt; for entering some useful info is located under this wonderful masterpiece. The app looks in the following way:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/findelementsinhostcoordinates/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Now we will add a mouse click event handler: we will get the elements we clicked on. Here we will use two versions of &lt;code&gt;VisualTreeHelper.FindElementsInHostCoordinates&lt;/code&gt; (for point and for rectangle):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static IEnumerable FindElementsInHostCoordinates(
 Point intersectingPoint,
 UIElement subtree
)
public static IEnumerable FindElementsInHostCoordinates(
 Rect intersectingRect,
 UIElement subtree
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A list of elements we get will be displayed in &lt;code&gt;StatusBlock&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private void OnMainCanvasMouseLeftButtonDown(object sender, 
                                             MouseButtonEventArgs e)
{
  var p = e.GetPosition(MainCanvas);
  var listPoint = VisualTreeHelper.FindElementsInHostCoordinates(
                    new Point(p.X, p.Y), MainCanvas).ToList();
  var listRect = VisualTreeHelper.FindElementsInHostCoordinates(
                    new Rect(p.X, p.Y, 1, 1), MainCanvas).ToList();
  var strPoint = string.Join(&amp;quot;, &amp;quot;, 
                   listPoint.Select(el =&amp;gt; el.GetType().Name.ToString()));
  var strRect = string.Join(&amp;quot;, &amp;quot;, 
                   listRect.Select(el =&amp;gt; el.GetType().Name.ToString()));
  StatusBlock.Text = string.Format(&amp;quot;[{0}] vs [{1}]&amp;quot;, strPoint, strRect);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our perfect app is ready! Something tells me that considering the rectangle size (1&#215;1) results of two method overloads won’t differ. Let’s check it by clicking on different areas. The picture below shows the result of this test:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/findelementsinhostcoordinates/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Everything seems to be ok: all methods work as expected. Now let’s proceed to WinRT. Create a new Windows Store application and add the same markup to it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Grid Background=&amp;quot;{StaticResource ApplicationPageBackgroundThemeBrush}&amp;quot;&amp;gt;
  &amp;lt;Grid.RowDefinitions&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;*&amp;quot;/&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;100&amp;quot;/&amp;gt;
  &amp;lt;/Grid.RowDefinitions&amp;gt;

  &amp;lt;Canvas Tapped=&amp;quot;OnMainCanvasTapped&amp;quot; 
          x:Name=&amp;quot;MainCanvas&amp;quot; Background=&amp;quot;LightGreen&amp;quot;&amp;gt;
    &amp;lt;Ellipse Width=&amp;quot;200&amp;quot; Height=&amp;quot;200&amp;quot; Fill=&amp;quot;LightCoral&amp;quot; /&amp;gt;
    &amp;lt;Path Fill=&amp;quot;LightBlue&amp;quot; Data=&amp;quot;M 10,100 C 10,300 300,-200 300,100&amp;quot;/&amp;gt;
  &amp;lt;/Canvas&amp;gt;

  &amp;lt;TextBlock Grid.Row=&amp;quot;1&amp;quot; x:Name=&amp;quot;StatusBlock&amp;quot; /&amp;gt;
&amp;lt;/Grid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Code of the &lt;code&gt;OnMainCanvasTapped&lt;/code&gt; handler matched &lt;code&gt;OnMainCanvasMouseLeftButtonDown&lt;/code&gt; code. Let’s run the application and click on it. Results look as follows:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/findelementsinhostcoordinates/screen3.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;What a turn out! A short test of the app results in the following conclusion: point &lt;code&gt;HitTest&lt;/code&gt; works in the same way as in the Silverlight application while rectangle HitTest for the Path-figures works not for the figure itself, but for its BoundingBox. WinRT applications are created based on the Touch First principle, that’s why Rect-version of the code if more interesting. In most cases this issue won’t be critical, but if an application is oriented to interaction with various arcuate elements, it’s better to pay special attention to the behavior of &lt;code&gt;FindElementsInHostCoordinates&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/silverlight/strange-behavior-of-findelementsinhostcoordinates-in-winrt/&quot;&gt;blogs.perpetuumsoft.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dotnet/system-drawing-color-equals/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dotnet/system-drawing-color-equals/'/>
              <title>About System.Drawing.Color and operator ==</title>
              <updated>2014-02-21T16:58:00Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;Operator &lt;code&gt;==&lt;/code&gt; that allows easy comparison of your objects is overridden for many standard structures in .NET. Unfortunately, not every developer really knows what is actually compared when working with this wonderful operator. This brief blog post will show the comparison logic based on a sample of &lt;code&gt;System.Drawing.Color&lt;/code&gt;. What do you think the following code will get:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var redName = Color.Red;
var redArgb = Color.FromArgb(255, 255, 0, 0);
Console.WriteLine(redName == redArgb);
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;“It’s red here and it’s red there. Probably, the objects should be equal”, the reader might think. Let’s open &lt;a href=&quot;http://www.dotnetframework.org/default.aspx/Net/Net/3@5@50727@3053/DEVDIV/depot/DevDiv/releases/whidbey/netfxsp/ndp/fx/src/CommonUI/System/Drawing/Color@cs/1/Color@cs&quot;&gt;source code&lt;/a&gt; and review the operator &lt;code&gt;==&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static bool operator ==(Color left, Color right) {
    if (left.value == right.value
        &amp;amp;&amp;amp; left.state == right.state
        &amp;amp;&amp;amp; left.knownColor == right.knownColor) {

        if (left.name == right.name) {
            return true;
        }

        if (left.name == (object) null || right.name == (object) null) {
            return false;
        }

        return left.name.Equals(right.name);
    }

    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Code review help us make an interesting conclusion: colors are compared by the Name property rather than the ARGB-value. What are the names of our objects? Let’s see.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(redName.Name); // Red
Console.WriteLine(redArgb.Name); // ffff0000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hmm, they’ve got different names. So, the expression &lt;code&gt;redName == redArgb&lt;/code&gt; gets &lt;code&gt;False&lt;/code&gt;. There may occur an irritating situation, for example, when initial &lt;code&gt;Color.Red&lt;/code&gt; was serialized to ARGB and then de-serialized back and then you decided to compare the final color with the original. Let’s read what &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color.op_equality(v=vs.110).aspx&quot;&gt;MSDN&lt;/a&gt; says about operator &lt;code&gt;==&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This method compares more than the ARGB values of the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color(v=vs.110).aspx&quot;&gt;Color&lt;/a&gt; structures. It also does a comparison of some state flags. If you want to compare just the ARGB values of two Color structures, compare them using the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color.toargb(v=vs.110).aspx&quot;&gt;ToArgb&lt;/a&gt; method.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Everything is clear now. In order to compare our colors we need the &lt;code&gt;ToArgb&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(redName.ToArgb() == redArgb.ToArgb()); // True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;I think you shouldn’t relay on a guess about logic of the standard comparison methods even if they might seem obvious to you. If you use operator == or Equals method for value types it would be a good idea to have a look at the documentation and check what will be actually compared.&lt;/p&gt;
&lt;h2&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/about-system-drawing-color-and-operator/&quot;&gt;blogs.perpetuumsoft.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dotnet/msbuild-configurations/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dotnet/msbuild-configurations/'/>
              <title>Setting up build configuration in .NET</title>
              <updated>2014-02-07T17:16:00Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;You get two default build configurations: Debug and Release, when creating a new project in Visual Studio. And it’s enough for most small projects. But there can appear a necessity to extend it with the additional configurations. It’s ok if you need to add just a couple of new settings, but what if there are tens of such settings? And what if your solution contains 20 projects that need setting up of these configurations? In this case it becomes quite difficult to manage and modify build parameters.&lt;/p&gt;
&lt;p&gt;In this article, we will review a way to make this process simpler by reducing description of the build configurations.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Open csproj file of one of your projects, you will find the following strings there:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
  &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
  &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
  &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
  &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
  &amp;lt;OutputPath&amp;gt;bin\Debug\&amp;lt;/OutputPath&amp;gt;
  &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
  &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
  &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
  &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
  &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
  &amp;lt;OutputPath&amp;gt;bin\Release\&amp;lt;/OutputPath&amp;gt;
  &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
  &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first problem we face with is that the strings are duplicated (or almost duplicated) in all projects. Luckily, csproj files support export of configurations. So, let’s create the &lt;code&gt;Configurations.targets&lt;/code&gt; file in the solution root folder. It will contain:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Debug\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Release\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After that you will be able to change the corresponding strings in the source csproj file to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Import Project=&amp;quot;..\Configurations.targets&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cool, we got rid of the duplicated configuration descriptions. Now we can focus on editing of a single file. You can notice that some strings are still duplicated in Debug and Release configurations. Assume that a developer wants to setup all these parameters individually for every configuration. If there is no such need, it’s possible to take the duplicated lines out to the common &lt;code&gt;PropertyGroup&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Debug\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Release\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is it possible to enhance anything else? Let’s think. The eye catches &lt;code&gt;OutputPath&lt;/code&gt; which can be figured out from the configuration name. When you have two configurations you can set individual settings for each of them. But if you have quite a lot of configurations it would be great to make &lt;code&gt;OutputPath&lt;/code&gt; figure out of the configuration name. Here we get the &lt;code&gt;$(Configuration)&lt;/code&gt; variable that will help us to determine this name.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great! We got rid of duplication. What else can be optimized? As a rule, the properties being set up depend only on the configuration; change of the platform doesn’t influence anything. Let’s remove this unnecessary condition.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)&#39; == &#39;Debug&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)&#39; == &#39;Release&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let’s add new configurations. Assume we want to add a Demo mode to the application. Not all features are available in this mode. The Demo mode may also require debugging that is why it’s reasonable to create &lt;code&gt;DebugDemo&lt;/code&gt; and &lt;code&gt;ReleaseDemo&lt;/code&gt; configurations. And, for example, we want to add a build mode that will require a user to use a license. We may also want to license Demo version. So, we have 4 more configurations: &lt;code&gt;DebugLicense&lt;/code&gt;, &lt;code&gt;ReleaseLicense&lt;/code&gt;, &lt;code&gt;DebugDemoLicense&lt;/code&gt;, &lt;code&gt;ReleaseDemoLicense&lt;/code&gt;. This situation is just a sample, your project can be absolutely different. &lt;code&gt;Demo&lt;/code&gt; and &lt;code&gt;License&lt;/code&gt; will add new variables to &lt;code&gt;DefineConstants&lt;/code&gt;. It seems that you just need to create 8 separate &lt;code&gt;PropertyGroups&lt;/code&gt; for 8 configurations. But something in my mind begins to protest. Luckily, you can add a more complicated condition than just comparison to the &lt;code&gt;Condition&lt;/code&gt;. In this sample, we will search for the set substring in the configuration name:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;!-- Conditional --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Debug&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Release&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;License&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);LICENSE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Demo&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);DEMO&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;  
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looks quite good. There is a little problem: Visual Studio can’t get a list of available configurations. This issue can be solved by adding empty &lt;code&gt;PropertyGroups&lt;/code&gt; with the same &lt;code&gt;Condition&lt;/code&gt; as in the beginning. And you can add only those configurations you will actually use in your work. For example, we don’t want to debug &lt;code&gt;Demo&lt;/code&gt; and &lt;code&gt;License&lt;/code&gt; configurations. In this case we can write the following strings:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;!-- Conditional --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Debug&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Release&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;License&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);LICENSE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Demo&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);DEMO&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;  

  &amp;lt;!-- Available --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemo|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemoLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you’ve got the inborn hatred to duplication of anything, you can take out additional properties duplicated in all projects to the file you’ve got. For example, in this way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;Configuration Condition=&amp;quot; &#39;$(Configuration)&#39; == &#39;&#39; &amp;quot;&amp;gt;Release&amp;lt;/Configuration&amp;gt;
    &amp;lt;Platform Condition=&amp;quot; &#39;$(Platform)&#39; == &#39;&#39; &amp;quot;&amp;gt;AnyCPU&amp;lt;/Platform&amp;gt;    
    &amp;lt;TargetFrameworkVersion&amp;gt;v4.0&amp;lt;/TargetFrameworkVersion&amp;gt;
    &amp;lt;SolutionDir Condition=&amp;quot;$(SolutionDir) == &#39;&#39; Or $(SolutionDir) == &#39;*Undefined*&#39;&amp;quot;&amp;gt;..\&amp;lt;/SolutionDir&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;!-- Conditional --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Debug&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Release&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;License&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);LICENSE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Demo&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);DEMO&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;  

  &amp;lt;!-- Available --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemo|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemoLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we got rid of all duplication for sure. And it’s so easy to setup configurations. I’d like to notice that this approach may not suit you; many projects are perfectly developed without editing of the configurations. And sometimes it’s necessary to setup each configuration for each project and for each platform manually – in this case you won’t be able to save your time by removing duplications. But if you’ve got a problem with setting up of quite a lot of configurations for quite a lot of projects, this practice may be a good fit. You can also get more information on build in MSDN.&lt;/p&gt;
&lt;h2&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/0k6kkbsd.aspx&quot;&gt;MSBuild Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms164307.aspx&quot;&gt;MSBuild Conditional Constructs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/7szfhaft.aspx&quot;&gt;MSBuild Conditions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd633440.aspx&quot;&gt;Expand Property Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms171459.aspx&quot;&gt;How to: Use Environment Variables in a Build&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb629394.aspx&quot;&gt;Common MSBuild Project Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb629388.aspx&quot;&gt;Common MSBuild Project Items&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/setting-up-build-configuration-in-net/&quot;&gt;blogs.perpetuumsoft.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dotnet/jon-skeet-quiz/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dotnet/jon-skeet-quiz/'/>
              <title>Jon Skeet&#39;s Quiz</title>
              <updated>2013-11-03T06:07:00Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;Jon Skeet was once asked to give three questions to check how well you know C#. He asked the &lt;a href=&quot;http://www.dotnetcurry.com/magazine/jon-skeet-quiz.aspx&quot;&gt;following questions&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q1.&lt;/strong&gt; &lt;em&gt;What constructor call can you write such that this prints True (at least on the Microsoft .NET implementation)?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object x = new /* fill in code here */;
object y = new /* fill in code here */;
Console.WriteLine(x == y);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Note that it’s just a constructor call, and you can’t change the type of the variables.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q2.&lt;/strong&gt; &lt;em&gt;How can you make this code compile such that it calls three different method overloads?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;void Foo()
{
    EvilMethod&amp;lt;string&amp;gt;();
    EvilMethod&amp;lt;int&amp;gt;();
    EvilMethod&amp;lt;int?&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q3.&lt;/strong&gt; &lt;em&gt;With a local variable (so no changing the variable value cunningly), how can you make this code fail on the second line?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;string text = x.ToString(); // No exception
Type type = x.GetType(); // Bang!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These questions seemed interesting to me, that is why I decided to discuss the solutions.&lt;!--more--&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A1-1.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One of the simplest ways is using &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/1t3y8s4s(v=vs.90).aspx&quot;&gt;Nullable&lt;/a&gt; types:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object x = new int?();
object y = new int?();
Console.WriteLine(x == y);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In spite of the explicit call of the constructor, values we got are equal to null and thus they match.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A1-2.&lt;/strong&gt;
Or you can remember of &lt;a href=&quot;http://blogs.msdn.com/b/ericlippert/archive/2009/09/28/string-interning-and-string-empty.aspx&quot;&gt;string interning&lt;/a&gt; and declare two empty strings:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object x = new string(new char[0]);
object y = new string(new char[0]);
Console.WriteLine(x == y);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A2.&lt;/strong&gt; The second question is the most complicated one. It’s necessary to offer the solution which calls tree different method overloads. I can suggest the following code as a sample:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class ReferenceGeneric&amp;lt;T&amp;gt; where T : class { }

public class EvilClassBase
{
  protected void EvilMethod&amp;lt;T&amp;gt;()
  {
    Console.WriteLine(&amp;quot;int?&amp;quot;);
  }
}

public class EvilClass : EvilClassBase
{
  public void Run()
  {
    EvilMethod&amp;lt;string&amp;gt;();
    EvilMethod&amp;lt;int&amp;gt;();
    EvilMethod&amp;lt;int?&amp;gt;();
  }

  private void EvilMethod&amp;lt;T&amp;gt;(ReferenceGeneric&amp;lt;T&amp;gt; arg = null) where T : class
  {
    Console.WriteLine(&amp;quot;string&amp;quot;);
  }

  private void EvilMethod&amp;lt;T&amp;gt;(T? arg = null) where T : struct
  {
    Console.WriteLine(&amp;quot;int&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s consider &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; types. Here it’s quite simple: &lt;code&gt;string&lt;/code&gt; is a reference type and &lt;code&gt;int&lt;/code&gt; is a value type. The following constructions will help us write the code: &lt;code&gt;where T : class&lt;/code&gt;, &lt;code&gt;where T : struct&lt;/code&gt;. The default parameters will explicitly use &lt;code&gt;T&lt;/code&gt; type in the corresponding way: the first method will use argument of the following type: &lt;code&gt;ReferenceGeneric&amp;lt;T&amp;gt;&lt;/code&gt; (it can accept only reference types), and the second method will use &lt;code&gt;T&lt;/code&gt;? (it can accept only value non-nullable types). Now calls of &lt;code&gt;EvilMethod&amp;lt;string&amp;gt;()&lt;/code&gt; and &lt;code&gt;EvilMethod&amp;lt;int&amp;gt;()&lt;/code&gt; will get correct overloads.&lt;/p&gt;
&lt;p&gt;Let’s proceed to &lt;code&gt;int?&lt;/code&gt;. We will create overload with a signature without any additional conditions &lt;code&gt;EvilMethod&amp;lt;T&amp;gt;()&lt;/code&gt; (unfortunately, C# doesn’t allow you to write anything of this kind &lt;code&gt;where T : Nullable&amp;lt;int&amp;gt;&lt;/code&gt;). But if you declare this method in the same class, it will get calls of the first two methods. That is why you need to send it the base class.&lt;/p&gt;
&lt;p&gt;Let’s look at what we have. Calls of &lt;code&gt;EvilMethod&amp;lt;string&amp;gt;()&lt;/code&gt; and &lt;code&gt;EvilMethod&amp;lt;int&amp;gt;()&lt;/code&gt; will see the suitable overloads in the current class and will use them. Call of &lt;code&gt;EvilMethod&amp;lt;int?&amp;gt;()&lt;/code&gt; won’t find a suitable overload in the current class and will apply to the base class for it. Power of &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa691336%28v=vs.71%29.aspx&quot;&gt;C# Overload resolution rules&lt;/a&gt; helped us once again!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A3.&lt;/strong&gt; Again, Nullable types will help us!&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var x = new int?();
string text = x.ToString(); // No exception
Type type = x.GetType(); // Bang!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/9hd15ket.aspx&quot;&gt;Remember&lt;/a&gt; that &lt;code&gt;ToString()&lt;/code&gt; method is overloaded in &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, it will get an empty string for the null value. Unfortunately, this trick won’t work for &lt;code&gt;GetType()&lt;/code&gt;. It can’t be overloaded and will through an exception for the null value. You can also &lt;a href=&quot;http://stackoverflow.com/questions/12725631/nullable-type-gettype-throws-exception&quot;&gt;read&lt;/a&gt; the Jon’s original answer to this question.&lt;/p&gt;
&lt;p&gt;Don’t forget that if you really want you can always access methods table via the unmanaged code and manually substitute reference to &lt;code&gt;GetType()&lt;/code&gt;, but we were asked not to shuffle =).&lt;/p&gt;
&lt;h2&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/jon-skeets-quiz/&quot;&gt;blogs.perpetuumsoft.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dev/perfect-code-and-real-projects/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dev/perfect-code-and-real-projects/'/>
              <title>Perfect code and real projects</title>
              <updated>2013-08-27T17:07:00.001Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;I’ve got a problem. I am a perfectionist. I like perfect code. This is not only the correct way to develop applications but also the real proficiency. I enjoy reading a good listing not less than reading a good book. Developing architecture of a big project is no simpler than designing architecture of a big building. In case the work is good the result is no less beautiful. I am sometimes fascinated by how elegantly the patterns are entwined in the perfect software system. I am delighted by the attention to details when every method is so simple and understandable that can be a classic sample of the perfect code.&lt;/p&gt;
&lt;p&gt;But, unfortunately, this splendor is ruined by stern reality and real projects. If we talk about production project, users don’t care how beautiful your code is and how wonderful your architecture is, they care to have a properly working project. But I still think that in any case you need to strive for writing good code, but without getting stuck on this idea. After reading various holy-war discussions related to correct approaches to writing code I noticed a trend: everyone tries to apply the mentioned approaches not to programming in general, but to personal development experience, to their own projects. Many developers don’t understand that good practice is not an absolute rule that should be followed in 100% of scenarios. It’s just an advice on what to do in most cases. You can get a dozen of scenarios where the practice won’t work at all. But it doesn’t mean that the approach is not that good, it’s just used in the wrong environment.&lt;/p&gt;
&lt;p&gt;There is another problem: some developers are not that good as they think. I often see the following situation: such developer got some idea (without getting deep into details) in the big article about the perfect code and he started to use it everywhere and the developer’s code became even worse. And then I have to listen to: “they read articles about these approaches and then start writing code in this way”. And what if this is not about the articles? If some programmers use good practices inappropriately it doesn’t mean that good development practices shouldn’t be discussed. Willingness to write correct code is good, but it’s necessary to estimate development skills soberly. There are a lot of maneuvers of stunt flying described for pilots. But it doesn’t mean that every newbie pilot should try to do them all in the very first flight. The same thing is for junior programmers: he doesn’t need to use tens of patterns he got to know after reading the book of GoF in his next project.&lt;/p&gt;
&lt;p&gt;But let’s get back to the discussion of the perfect code. Approach to the correct programming depends on many factors: on purpose, terms, team, etc. I’d like to review several types of projects that have absolutely different purposes. Let’s think to what extent the code should be clear and to what extent the architecture should be elaborated in each case. We will see patterns used in some projects that are inappropriate in other projects. Next time when you got outraged by some advice in a development related article, you should first think what purpose an author had. Maybe this is not advice that is bad, and just your project differs from the author’s one. So, let’s start.&lt;/p&gt;
&lt;h2&gt;Project size&lt;/h2&gt;
&lt;h3&gt;Small projects&lt;/h3&gt;
&lt;p&gt;For example, there is one man who develops the project for several days. It is some simple utility that solves a small separate task. Most likely it won’t be actively developed and transformed into something big. You can keep in mind all system elements (and even variables) in such projects. You don’t need sophisticated architecture in this project: if you get a task that can be resolved with a two code lines patch, you better do it. Of course, you can spend two days to develop a complicated architecture that will be convenient to use when new simple tasks arise. But there is a nuance: these simple tasks will hardly appear in such a small project while time has been already spent. In this situation, you don’t need to think about writing the perfect code. You shouldn’t write explicitly bad code as well, just do it right.&lt;/p&gt;
&lt;h3&gt;Medium size projects&lt;/h3&gt;
&lt;p&gt;Assume we’ve got a team of 5-6 developers and the project for several months. You can’t dabble here; it’s necessary to think over the system and structure the complete code. It’s better to control the amount of workarounds. Developers can spend some time for initial research, analysis and design, but not too much. It’s good if you manage to create an ideal plan for development of the ideal system by the deadline, but it’s even much better to develop not a very ideal but working system. At worst, if everything goes wrong, it’s not that difficult to re-design the whole architecture by all team members (I had to do it for several times, it’s not that horrible). If this is a custom development project, a customer will pay not for the wonderful code, but for working features implemented in time. Don’t forget about it.&lt;/p&gt;
&lt;h3&gt;Big projects&lt;/h3&gt;
&lt;p&gt;And now we have dozens of developers and the project will be developed for several years. And here it’s better to think over the architecture carefully from the very beginning. If there is a need for a workaround then maybe it’s better to re-design the architecture on early stages in the way that new features fit into it seamlessly. Every improper line of code written now will turn into great sufferings in a year or two. Read books about clear coding and correct architecture; they contain much advice that will come in handy. You just need to use it correctly, not everywhere. I like a story from the Martin Fowler’s book: Fowler did some consulting for a company that developed quite a big project. The project code was terrible and Fowler insisted on a slight refactoring. In a couple of days, they managed to get rid of half code without any damage to the system functionality. Programmers were very glad, but executives were not that happy since this work didn’t result in new features. The old code worked and its optimization didn’t seem economically viable. That is why further consulting recommendations were not followed by the executives. They forced sooner development of new features without any additional work on the code. In half a year the project was closed as the code became too complicated to maintain.&lt;/p&gt;
&lt;h2&gt;Project maintenance&lt;/h2&gt;
&lt;h3&gt;Projects without maintenance&lt;/h3&gt;
&lt;p&gt;Activity that is well known by various freelancers and outsourcers. After the project is delivered you will never remember all this horror hidden under the car hood. Deep in your mind, you hope that they will just use the project and no one will ever review the source code. And this is an acceptable approach, since we are required to provide a working application, but not the perfect code. In the very beginning of the project you can afford designing architecture, writing correct code. But when there is just two days till the deadline and only half of features are implemented, it’s not about lofty matters. It’s allowed to add any workarounds, infringe all imaginable approaches to good code. And this is ok in this case. I don’t say this is good and don’t guide to make it in this way. But this is normal. Here we talk about programming not as about art, here we talk about the project that should be delivered in time and that won’t be maintained. If you start writing everything ideally, you get a risk to exceed the time frame. You will quit on the customer, won’t get money, loose your time and code won’t be demanded by anyone. You should always remember about the purposes.&lt;/p&gt;
&lt;h3&gt;Maintained projects&lt;/h3&gt;
&lt;p&gt;And here I would write the good code, get right architecture and clear code. This is such a wonderful feeling when a customer asks you to add some sophisticated feature and you cope with this task in an hour. And this is because new code can be easily added to the project since it is ideally laid on the existing architecture. It’s so easy to work with the existing code base; the code is understandable and easy-to-orientate. And there is another feeling when a customer asks to add some minor feature (the customer is just absolutely sure this is a minor feature and easy to add) and you look at the classes cacophony, try to estimate how many days you would spend on this minor functionality, but for some reason you don’t even want to touch the keyboard. You can’t even look at this code.&lt;/p&gt;
&lt;h2&gt;Project publicity&lt;/h2&gt;
&lt;h3&gt;In-house projects&lt;/h3&gt;
&lt;p&gt;You create a project for you or your team and won’t make it public. In this case you are allowed a lot of things. No one makes you digress from your ideals in software development, but if you want to, you can – there is nothing improper. There is no need to create detailed documentation, you can write comments in your native language (if everyone engaged in the project understands it), and some complicated architectural solutions can be explained to your team members orally. I don’t say that you should certainly do it in this way. But if you are in a hurry some good practices can be ignored.&lt;/p&gt;
&lt;h3&gt;Public projects&lt;/h3&gt;
&lt;p&gt;Here is an absolutely different situation. Here you need to document your project properly, so that you don’t get hundreds of questions from your customers every day. And you better write comments in English to make it easy for everyone to understand them. If you have an API, you better think over it; don’t add some interface which will allow you to get all necessary data only if you really need to. Remember that the project belongs not only to you, but also to third party developers. Respect those developers who will work with your code. Write code in the way that won’t make others want to stop you in the dark backstreet and hurt you.&lt;/p&gt;
&lt;h2&gt;Specific projects&lt;/h2&gt;
&lt;h3&gt;Highload projects&lt;/h3&gt;
&lt;p&gt;Highload is a separate matter. In practice, you have to sacrifice a lot of things including good architecture and understandable code for high productivity. Sometimes you may want to cry when you look at what your cozy project turned to after optimization. But what can you do? Instead, program execution time reduced twice. Sometimes you don’t have a choice.&lt;/p&gt;
&lt;h3&gt;Projects using third-party libraries&lt;/h3&gt;
&lt;p&gt;When I talk about third-party libraries some my associates start looking at me understandingly. I see in their faces – they suffered in the same way. In real conditions of the big project you will hardly develop absolutely all functionality. There are usually quite common tasks that have been already solved by someone. In this situation it’s reasonable to use a ready-made solution than to reinvent the wheel. This is it, but sometimes it appears that authors of this ready solution are not good programmers. Their project solves its main task, but it’s developed…not really professionally. And integrating it into your project is… not really easy. This circumstance makes you add terrible kludges spoiling your fine architecture. But this is an operational need since it’s not cost-effective to implement this functionality on your own. (I will tell you in secret, several times I couldn’t bear it and developed my own library instead of using the third-party one. But this is an exception, not a rule.)&lt;/p&gt;
&lt;h3&gt;Project of newbie developers&lt;/h3&gt;
&lt;p&gt;You can often hear that an average developer should know this and that. It’s assumed that a developer knows some programming language (if we talk about OOP-language, he should at least know polymorphism and inheritance), he can understand complex syntax constructions, basic platform mechanisms, he knows common patterns (when he sees a class named Visitor, he will immediately understand the definite system part), he easily reads comments in English and can do much more things. But before becoming an average developer everyone was a newbie developer. And nowadays there are a lot of people who begin to study this science. And this is ok that they don’t know and can’t do a lot of things. This is a usual situation when some novice developers form a team and start developing a project. They learn many new tricks while developing the project. Of course they will do a lot of things in improper way. And you shouldn’t expect the opposite. It would be good if senior colleagues help with different issues: how to re-write code in a better way, what books to read, etc. But you shouldn’t specify the same requirements as to senior staff. Junior developers’ project may have lots of deviation from “how it should be” as they are just studying. Advice and recommendations are good while the requirement to write an ideal architecture from the first time is not that good.&lt;/p&gt;
&lt;h2&gt;Non-production projects&lt;/h2&gt;
&lt;h3&gt;Demo projects&lt;/h3&gt;
&lt;p&gt;Sometimes I have to create demo projects to show some great features to my associates. It can be language, engine, library or something else they haven’t seen before. As a rule, the project should be detailed and simple with lots of comments. In some cases there are tens of lines of comments for a single line of code and this is ok. You don’t write the perfect code, you just use the code as illustration. At the same time the code can be very bad and execute for too long. It doesn’t matter as we have a different purpose to demonstrate some technology to the public.&lt;/p&gt;
&lt;h3&gt;Research projects&lt;/h3&gt;
&lt;p&gt;In this project, we don’t show anything to anyone. We want to understand some new interesting feature by ourselves. Let’s say we examine some algorithm. It’s ok to write 10 versions of the algorithm side by side. Probably, versions will be in different languages. It will be ok not to care about the agreement on names (that is good to follow when creating a real project) and to name the same things in the same way – by names set in the book. It doesn’t matter what’s the common practice in this or that language. We examine the algorithm; we don’t care about such things right now. If you are going to show the result to someone else you should work over the code, but this is another story. And while you are on the research stage your main purpose is the research, not the perfect code. Of course, you can combine these things, but this is not obligatory. The main thing is not to substitute the academic purpose with the perfect code purpose.&lt;/p&gt;
&lt;h3&gt;Local projects&lt;/h3&gt;
&lt;p&gt;Many developers can say that it is necessary to get used to write good code everywhere. But local code has some specific, you don’t need to show it to anyone, you don’t need to report to anyone, you can be guided by your own ideas in development. There can appear a lot of bad intermediate code in the workflow. You can play with the platform, make some experiments. You can develop in the way convenient for you. You can create some data dump regardless of the general architecture and just save it to a local file from the most unacceptable place. It’s possible to write any amount of comments in any language, if this is more convenient for you.&lt;/p&gt;
&lt;p&gt;But remember that the situation changes when the creative process ends and you need to show the results to others (send local developments to the central repository). You need to clear the code in this case. All the experiments, kludges and excessive comments should be removed. Respect developers who will have to understand your writings.&lt;/p&gt;
&lt;h3&gt;Prototype projects&lt;/h3&gt;
&lt;p&gt;The main purpose of such projects is to quickly create some features to get the idea how they will look like. This is a reasonable approach. Let’s say we have 5 different implementations: we will chuck together a common concept of each variant. After that you will be able to examine all approaches on live samples and choose the one that will be used in the main project. It’s important to understand prototyping tasks. You don’t need to clear this code, you don’t need to write it ideally. I am always impressed by people who criticize a prototype with the following statements: “this variable could be named in a more understandable manner” or “it would be good to move this interface button 1 pixel to the left”. Does it matter how the variable is named? This is a prototype, back off. Such discussion is reasonable for a finished project, but it has no sense for a prototype.&lt;/p&gt;
&lt;h3&gt;Entertainment projects&lt;/h3&gt;
&lt;p&gt;I remember that once I and my friends decided to make a birthday present to a good man. We created a Java project which represented in OOP his life, friends and other interesting things he interacts with. The program really worked, it was possible to execute some funny commands from the console. As to the source code, absolutely all names (classes, methods, variables, etc.) were written in Russian (Java allows such tricks). Javadoc was also written in Russian and didn’t contain any useful information. Logic was implemented in the simplest way. We used the simplest algorithms instead of the complicated ones. Architecture wasn’t too pretty; we even didn’t try to think over it.&lt;/p&gt;
&lt;p&gt;And the present worked out, though we haven’t used any good practice of writing the perfect code. And the matter is in absolutely different purposes of the project.&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Once again I would like to draw your attention to main ideas. If you want to become a good programmer, you should develop, learn to write better code, work to improve yourself. You should try to write as clear and good code as possible. But you need to understand that your code will never be ideal in a big project. You shouldn’t admit bad code; write it in the way that you won’t be ashamed of. At the same time don’t forget about the project purpose since in most cases the perfect code is not the purpose, but means to reach it. It’s not necessary to intentionally write bad code, but show no fanaticism about the perfect code as well. Remember about your purposes and situation. It’s not that easy to write good code. Compare your effort spent for code improvement and the result it will get. If you read a good article about the good code, don’t extract separate pieces of advice that you will use everywhere without a second thought. Pay attention to the context of the given advice. Think of the situation described in the article. Think when it’s appropriate to use known patterns and when it’s not. And in general, think more, it’s very useful in programming. And everything will be ok for you.&lt;/p&gt;
&lt;h2&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/perfect-code-and-real-projects-part-1/&quot;&gt;blogs.perpetuumsoft.com, Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/perfect-code-and-real-projects-part-2/&quot;&gt;blogs.perpetuumsoft.com, Part 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dev/comments/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dev/comments/'/>
              <title>To Add Comments or Not to Add?</title>
              <updated>2013-08-27T17:04:00.001Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;&lt;em&gt;A really good comment is the one you managed to avoid. (c) Uncle Bob&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Lately, I’ve been feeling really tired of hot discussions on if it’s necessary to add comments in the code. As a rule, there are self-confident juniors with the indisputable statement as: “Why not to comment it, it will be unreadable without the comments!” on one side. And experienced seniors are on the other side. They understand that if it’s possible to go without the comments than “You better, damn it, do it in this way!” Probably, many developers got comment cravings since they’ve been students when professors made them comment every code line, “to make the student better understand it”. Real projects shouldn’t contain a lot of comments that only spoil the code. I don’t agitate for avoiding comments at all, but if you managed to write the code that doesn’t need comments, you can consider it your small victory. I would like to refer you to some good books that helped form my position. I like and respect these authors and completely share their opinion.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670&quot;&gt;Steven C. McConnell, Code Complete&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882&quot;&gt;Robert Martin, Clean Code: A Handbook of Agile Software Craftsmanship&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amazon.com/The-Readable-Code-Theory-Practice/dp/0596802293&quot;&gt;Dustin Boswell, Trevor Foucher, The Art of Readable Code (Theory in Practice)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;p&gt;So, what makes me mad about the comments? Here are some main statements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Comments spoil the code itself, make it less readable;&lt;/li&gt;
&lt;li&gt;Comments require time for writing and maintenance;&lt;/li&gt;
&lt;li&gt;Comments lie (starting from the improperly composed comments and ending with the obsolete ones)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Basically, I agree that in some cases the comments are necessary. But the less such cases exist the more beautiful your code is. Besides, writing a good comment is the art as well. Unfortunately, just few developers have that skill, the rest of them write the comments anyhow. The benefit of such commenting is quite doubtful. Isn’t it better not to spend time and effort for writing a good comment but to spend it for re-writing the code in the way it could go without any comments?&lt;/p&gt;
&lt;p&gt;Let’s discuss some typical scenarios and define to what extent the comment is necessary. I provide C# code, but this is not that critical for this article.&lt;/p&gt;
&lt;h2&gt;When you can go without the comments&lt;/h2&gt;
&lt;h3&gt;Comments that repeat code&lt;/h3&gt;
&lt;p&gt;Let’s have a look at the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// This method is responsible for calculating array elements sum
// The method receives elements array at the input
public int CalcSumOfElement(int[] elements)
{
  int result = 0; // Creating a special variable for the result
  int n = elements.Length; // Defining array length, i.e. number of elements
  for (int i = 0; i &amp;lt; n; i++) // Running cycle for all elements
    result += elements[i]; // Adding an element to the result
  return result; // Returning the result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, this sample is fake, but unfortunately, I don’t overdo. I saw such code quite often. In this sample, the comments don’t provide any new information; everything can be understood from code. And reading this code without the comments would be much easier. I don’t even say about maintenance of such code: it’s quite tiresome to support this level of commenting. Most likely, when the code becomes more sophisticated half of code won’t have comments, the rest of code will include obsolete comments.&lt;/p&gt;
&lt;h3&gt;Comments explaining syntax&lt;/h3&gt;
&lt;p&gt;Here is the sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Item
{
  private int value; // This is a private field, it’s not available from outside

  // This is a constructor
  public Item(int twoValue)
  {
    value = twoValue &amp;gt;&amp;gt; 1; // Two characters don’t mean bitwise sift to the right
    // so, we divide the value in two
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If this is a laboratory research of a fresher, it’s ok. But if this is the production code and your developers need such comments, I’ve got bad news for you. Probably, this article is not for you.&lt;/p&gt;
&lt;h3&gt;Comments explaining standard classes&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;HashSet set; // This is data structure called Hash-Set
// It represents a set of elements
// We can easily find out if an element is included in this set
// More information on hash-tables can be found in wikipedia:
// http://ru.wikipedia.org/wiki
// /%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If a programmer really doesn’t know designation of some standard class or method, he can always use Google search / read documentation / ask an associate. Most good developers already know it. That’s why I strongly doubt usefulness of such comments.&lt;/p&gt;
&lt;h3&gt;Comments explaining improper names&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Setting up server connection
public void DoIt()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I agree that it’s not always possible to name a class/method/property/variable properly. And if the project deadline is yesterday, there is no time to think over good names. Let’s take some arbitrary name and explain what’s happening in the comments. This is much easier and quicker! Or you will spare a minute or two to give an understandable name?&lt;/p&gt;
&lt;h3&gt;Comments explaining a paragraph&lt;/h3&gt;
&lt;p&gt;I often hear the following phrases: “This method is 300 lines, it does lots of things. You can’t understand it without the comments. I will comment every 10 lines”. If this is the case, you, probably, do something wrong. May be it’s better to divide this big 300-lines method into several smaller methods. And give an understandable name to every small method. In this way you won’t need the comments.&lt;/p&gt;
&lt;h3&gt;Comments explaining constants&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public int GetSeconds(int hours)
{
  return hours * 3600; // 3600 – this is amount of seconds forming an hour
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this variant, availability of the comment is a more adequate variant that just a figure added to the code and meaning something. But it’s even better to create a named constant which name made everything understandable.&lt;/p&gt;
&lt;p&gt;For example, in this way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private const int SecondsInHour = 3600;
public int GetSeconds(int hours)
{
  return hours * SecondsInHour;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Comments not related to programming&lt;/h3&gt;
&lt;p&gt;I like a story from “Code Complete” about how a developer tried to understand the following comment for the whole night:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;MOV AX, 723h ; R. I. P. L. V. В.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Some months later he met the author of this code and learnt that the comment meant the following: &#171;Rest in peace, Ludwig van Beethoven&#187; as 723 is a hexadecimal view of the year of Beethoven’s death. Unfortunately, some programmers think that the code is some kind of a forum where they can communicate. Some of them try to be witty (nearly telling funny stories), others tell something about themselves (for example, “It’s 3.00am right now and I am still writing this class as I am fond of programming”). You don’t do it in this way; there are hundreds of other communication means. If the comment is included in the project it should add some value to this project.&lt;/p&gt;
&lt;h3&gt;Comments containing thoughts&lt;/h3&gt;
&lt;p&gt;It happens that a comment contains some smart ideas that are very useful. But very often this is not the case:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Main()
{
  // Well, this is a very useful method
  // It executes main logic of this class.
  // At first I wanted to name it Run.
  // But then I thought that Run means “to go quickly”.
  // And this method doesn’t run, it’s very slow.
  // I was thinking about it when washing the dishes.
  // And when I finished washing the dishes and got back to my computer I renamed the method to Main.
  // This is the main method of this class, let it be Main.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Comments containing use cases&lt;/h3&gt;
&lt;p&gt;Sometimes an author of the method is not sure that everybody will correctly understand how to use his method. And he gives use cases that demonstrate what the method gets with the definite data:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Sum(1, 2) == 3
// Sum(2, 1) == 3
// Sum(2, 2) == 4
public int Sum(int a, int b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I think that every task should have its own tool. And unit tests were created for this exact purpose. This is a very smart thing. Necessity of unit tests is a debatable topic as well. But if you need to describe samples of the returned results for the method, why not to do a corresponding unit test?&lt;/p&gt;
&lt;h3&gt;Comments containing code history&lt;/h3&gt;
&lt;p&gt;Luckily, I haven’t seen such comments for quite a long time. But sometimes I have to review the following comments: // 11.06.13: Fixed a bug in the method. Previously it worked in the following way, now it works in this way. // 12.06.13: Oops, that bug wasn’t a bug at all. Got everything back. I will repeat once again: there is a separate tool for every task. Source control systems are able to store change history. You don’t need to overload source code with unnecessary history of how the code was written. If anyone gets interested in it, he can always review it in the repository.&lt;/p&gt;
&lt;h3&gt;Comments containing code&lt;/h3&gt;
&lt;p&gt;Such comments make me especially sad. Let’s say you are reviewing the code of some good class and subbenly you see:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// int number = GetNumber()
// int number = 4;
// int number = 5;
int number = 4;
// double number = 4.5;
// decimal number = 4.5;
// string number = &amp;quot;This number&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What did author want to say in this comment? Some developers want to say: “I am making some experiments changing the code, but I don’t want to lose old versions of this code in case I will need to get back to them”. This phrase reminds us of the idea to use repository for this purpose, since it can store intermediate versions of your code and they won’t get lost. Take pity on the developers who will read your code. And the worst thing is that this code will stay in the project for a long time. The author just forgets to delete bad code version after a number of experiments. His associates are afraid to thoughtlessly delete the code which designation is unclear: “I will delete the thing and then it will occur that it was absolutely necessary.There was a great idea and I spoiled everything”.&lt;/p&gt;
&lt;h3&gt;Incomprehensible comments&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;bool flagA = true;
bool flagB = false;
bool flagC = true;
if (Condition(flagA, flagB, flagC))
  Foo();
// else checkbox true, turn off server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In such cases you can’t guess what an author wanted to say. What checkbox is true? Is it always set to true in the else-branch? Or is it necessary to add some code that will set the checkbox to true? What is the server? Why is it turned off? Will it turn off automatically? Or do we need to do it manually?&lt;/p&gt;
&lt;p&gt;Such comments are likely to do more harm, than good. It doesn’t contain any useful information and just confuses the reader. Don’t confuse your readers! Or don’t write anything at all. Or spend a little more time to write a message everyone will understand.&lt;/p&gt;
&lt;h3&gt;Comments containing too much text&lt;/h3&gt;
&lt;p&gt;Some commenters are afraid of being misunderstood. Or to provide too little information. That is why a comment for a three-lines method can take several screens. In this extensive essay, you will read about the used algorithms, their temporary complexity, see pseudo-code of the method, diagram in ASCII graphics, variable names rationale, some general ideas. And everything will be given in so many details to make even a first-grader understand it.&lt;/p&gt;
&lt;p&gt;This is a bad approach. It makes a reader spend much time to review your essay. If you decide to insert a comment take care about its laconism (of course, without prejudice to its readability and information value).&lt;/p&gt;
&lt;h3&gt;Comments that lie&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// two figures product
public int Sum(int a, int b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, you confuse your reader. What happens here? Probably, sometimes the method got a product and then it was converted to sum and the comment became obsolete. Or vice-versa, the comment was updated, but method name got out of attention. And may be the method got sum from the very beginning and a programmer just made a mistake while inserting a comment. The method can be very complicated and it can take much time to understand which one of the turtles lie.&lt;/p&gt;
&lt;h2&gt;When you can insert a comment&lt;/h2&gt;
&lt;h3&gt;Comments that add abstraction level&lt;/h3&gt;
&lt;p&gt;Domain scope can be very complicated. It’s not always possible to get simple and clear names for the classes that will immediately indicate the things they correspond to. That is why it’s ok to set some concise term to denote a complicated domain. Main team developers know it by heart. And it is good to insert a laconic comment for new team members that will explain everything.&lt;/p&gt;
&lt;h3&gt;Comments that explain unexplainable&lt;/h3&gt;
&lt;p&gt;It’s a pity, but sometimes you can’t write the code that is understandable as it is. Probably, some sophisticated algorithm is used. Or a coming deadline made you write a quick but not readable code. May be you need to deliver the project yesterday and have no time to put it in order. It doesn’t matter how the unreadable code got in your project. If it becomes more understandable, let the comment be added in the code.&lt;/p&gt;
&lt;h3&gt;TODO comments&lt;/h3&gt;
&lt;p&gt;The issue is disputable as well. Someone can say that there is an Issue Tracker, let’s store all tasks in it. Others can say that there is no need to generate lots of small issues when it’s possible to insert special comments that will attract developers’ attention to the fact that some functionality needs to be added. It’s good that today’s IDE’s can search for TODO comments and output them as a big fine list, so you won’t worry the instructions will be lost. It’s just necessary to agree within a team on what methodology will be used. Many programmers think that TODO comments are very convenient and there is no harm to use them.&lt;/p&gt;
&lt;h3&gt;Comments that attract attention&lt;/h3&gt;
&lt;p&gt;Sometimes there appear some important things in the code which you want your reader to pay attention to. But it’s impossible to do with the code means. For example, you need to warn a reader that the method executes for a long time. Or the class is being developed and refactored by several people, it contains some bad piece of code that needs to be deleted or revised. But you better don’t do it since it’s very important and everything will fail without it. In general, if there are some important but not obvious aspects of your code, you can add a comment, it won’t be excessive.&lt;/p&gt;
&lt;h3&gt;Comments that documentation&lt;/h3&gt;
&lt;p&gt;Many developers generate documentation based on the specific comments (such approach is used in many languages). There are other means to create documentation without the comments. But depending on some circumstances it’s a concept to use the comments for documenting, you can’t do anything with it. Here we talk about a public API, not about a private method in the in-house project. The team should agree on when and where this approach to documenting will be used. Time is priceless; don’t spend it for generating documentation that no one will read.&lt;/p&gt;
&lt;h3&gt;Comments containing legal information&lt;/h3&gt;
&lt;p&gt;Some projects require adding a header-comment with license or copyright information in every file. No discussions in this case.&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;I would like to focus on the main idea: though I insist on reduction of the comments number, it doesn’t mean that comments are evil incarnate that shouldn’t appear in the project. If you can justify the availability of a comment in this code snippet, if you really can’t avoid it, if you can compose it correctly and laconically – you’re welcome to insert a comment since it makes the source code more informative. Unfortunately, most comments don’t provide much benefit and just spoil the code. If you are about to write another wonderful comment, give yourself some more time to think if the comment is really wonderful, can’t you go without it?&lt;/p&gt;
&lt;p&gt;I also would like to note that, in real life, many things depend on the programming language, on IDE, on team agreements. Probably, in your definite situation it’s necessary to insert a lot of comments (it can be a complicated algorithm, low-level code, sophisticated optimizations, etc.). May be you are writing local code at the moment and comments make it more convenient to work with the code (though nobody makes you commit comments to the repository). It may occur that your project is 100 lines of code and it’s easier to add some comments than to create a complicated extensible architecture. In this article, I offered some general recommendations for a big project in a high-level language. These recommendations can save you and your associates from unnecessary headache. Just don’t consider the suggested practices as the absolute rules. You need to get the situation: is it appropriate to add a comment? Is it necessary here? Or it’s better to go without it? Just try to pay more attention to such things and your project will be better.&lt;/p&gt;
&lt;h2&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/to-add-comments-or-not-to-add/&quot;&gt;blogs.perpetuumsoft.com, Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/to-add-comments-or-not-to-add-part-2/&quot;&gt;blogs.perpetuumsoft.com, Part 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dotnet/gc-native/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dotnet/gc-native/'/>
              <title>Unexpected area to collect garbage in .NET</title>
              <updated>2013-08-08T05:42:00Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;The .NET framework provides an intelligent garbage collector that saves us a trouble of manual memory management. And in 95% of cases you can forget about memory and related issues. But the remaining 5% have some specific aspects connected to unmanaged resources, too big objects, etc. And it’s better to know how the garbage is collected. Otherwise, you can get surprises.&lt;/p&gt;
&lt;p&gt;Do you think GC is able to collect an object till its last method is complete? It appears it is. But it is necessary to run an application in release mode without debugging. In this case JIT compiler will perform optimizations that will make this situation possible. Of course, JIT compiler does it when the remaining method body doesn’t contain references to the object or its fields. It should seem a very harmless optimization. But it can lead to the problems if you work with the unmanaged resources: object compilation can be executed before the operation over the unmanaged resource is finished. And most likely it will result in the application crash. &lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Let’s reproduce the situation. For a beginning, we will need something unmanaged, for example &lt;a href=&quot;https://code.google.com/p/opencvsharp/&quot;&gt;OpenCvSharp&lt;/a&gt; that is a wrapper for &lt;a href=&quot;http://opencv.org/&quot;&gt;OpenCV&lt;/a&gt;, a computer vision and image processing library.&lt;/p&gt;
&lt;p&gt;I am talking about this library since I got this irritating issue using it. Have a look the following class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class ImageWithCircle
{
  private const int Size = 10000;
  private readonly IplImage image;

  public ImageWithCircle()
  {            
    image = Cv.CreateImage(new CvSize(Size, Size), BitDepth.U8, 3);
    DrawCircle();
  }

  ~ImageWithCircle()
  {
    Console.WriteLine(&amp;quot;~ImageWithCircle&amp;quot;);
    Cv.ReleaseImage(image);
  }

  public void Save()
  {
    Console.WriteLine(&amp;quot;Save start&amp;quot;);
    image.SaveImage(&amp;quot;image.tif&amp;quot;);
    Console.WriteLine(&amp;quot;Save end&amp;quot;);
  }

  public void DrawCircle()
  {
    image.FloodFill(new CvPoint(Size / 2, Size / 2), CvColor.White);
    image.Circle(new CvPoint(Size / 2, Size / 2), Size / 4, 
                 CvColor.Random(), 10);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is quite a simple class responsible for drawing a very big picture with a circle. There is a &lt;code&gt;Save()&lt;/code&gt; method that saves a picture to a file. Logic of the work with a picture is stored in the &lt;code&gt;IplImage&lt;/code&gt; class from OpenCvSharp. Run this code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;static void Main()
{
  new ImageWithCircle().Save();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The console will show an expected variant: we started &lt;code&gt;Save()&lt;/code&gt; method and ended it. Only after it garbage was collected and the corresponding finalizer is invoked.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Save start
Save end
~ImageWithCircle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now let’s call garbage collection while the picture is being saved. This is just a sample; that is why we won’t invent anything complicated and just enable &lt;code&gt;Timer&lt;/code&gt; that will call &lt;code&gt;GC.Collect()&lt;/code&gt; quite frequently. The picture is very big and we will call garbage collector at least once before it is saved to a file. So, the executable code now looks in the following way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private static void Main()
{
  var timer = new Timer(100);
  timer.Elapsed += RunGc;
  timer.Start();
  new ImageWithCircle().Save();
}

private static void RunGc(object sender, ElapsedEventArgs e)
{
  Console.WriteLine(&amp;quot;Gc.Collect();&amp;quot;);
  GC.Collect();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Probably, you expect to see something of this kind:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gc.Collect();
Gc.Collect();
Gc.Collect();
Save start
Gc.Collect();
Gc.Collect();
Gc.Collect();
Gc.Collect();
Gc.Collect();
Gc.Collect();
Save end
~ImageWithCircle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But if you run the application in release mode without debugging the app will crash:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gc.Collect();
Gc.Collect();
Gc.Collect();
Save start
Gc.Collect();
~ImageWithCircle

Unhandled Exception: System.AccessViolationException: Attempted to read or write
 protected memory. This is often an indication that other memory is corrupt.
   at OpenCvSharp.CvInvoke.cvSaveImage(String filename, IntPtr image, Int32[] pa
rams)
   at OpenCvSharp.Cv.SaveImage(String filename, CvArr image, ImageEncodingParam[
] prms)
   at ConsoleApplication.ImageWithCircle.Save() in d:\Tests\ConsoleApplica
tion\ConsoleApplication\ImageWithCircle.cs:line 28
   at ConsoleApplication.Program.Main() in d:\Tests\ConsoleApplication\Co
nsoleApplication\Program.cs:line 18
Gc.Collect();
Gc.Collect();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem is that JIT executed its insidious optimization: our object was subject to garbage collection before the picture is completely saved to a file. Unfortunately, OpenCvSharp couldn’t stand it and threw an exception.&lt;/p&gt;
&lt;p&gt;The issue can be easily fixed: it’s just necessary to keep reference to the current picture till the method completes its work. For example, you can use some static object to which the picture will write reference to itself in the beginning of the &lt;code&gt;Save()&lt;/code&gt; method. But I prefer to use the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.gc.keepalive.aspx&quot;&gt;GC.KeepAlive&lt;/a&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Save()
{
  Console.WriteLine(&amp;quot;Save start&amp;quot;);
  image.SaveImage(&amp;quot;image.tif&amp;quot;);
  Console.WriteLine(&amp;quot;Save end&amp;quot;);
  GC.KeepAlive(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Actually, it’s not important in what way you will fix the issue; the main thing is to understand how garbage collector works to foresee such problems. They are hard to discover: the application in the sample crashes only with definite start configuration, in case if the garbage collector is able to run while some time-consuming unmanaged method is executed. And if you occasionally get such application crash you will spend much time trying to reproduce it. To avoid such issues it is necessary to carefully design interaction with any native objects trying to foresee probable troubles before the code is written.&lt;/p&gt;
&lt;h2&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/unexpected-area-to-collect-garbage-in-net/&quot;&gt;blogs.perpetuumsoft.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dotnet/closures/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dotnet/closures/'/>
              <title>Unobviousness in use of C# closures</title>
              <updated>2013-08-07T09:35:00Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;C# gives us an ability to use closures. This is a powerful tool that allows anonymous methods and lambda-functions to capture unbound variables in their lexical scope. And many programmers in .NET world like using closures very much, but only few of them understand how they really work. Let’s start with a simple sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  int e = 1;
  Foo(x =&amp;gt; x + e);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nothing complicated happens here: we just captured a local variable &lt;code&gt;e&lt;/code&gt; in its lambda that is passed to some &lt;code&gt;Foo&lt;/code&gt; method. Let’s see how the compiler will expand such construction.*&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  DisplayClass c = new DisplayClass();
  c.e = 1;  
  Foo(c.Action);
}

private sealed class DisplayClass
{
  public int e;

  public int Action(int x)
  {
    return x + e;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;As you see from the sample, an additional class containing the captured variable and the target method is created for our closure. This knowledge will help us understand how closures behave in different situations.&lt;/p&gt;
&lt;h3&gt;The for loop&lt;/h3&gt;
&lt;p&gt;Probably, this is the most classic sample cited by everyone:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  for (int i = 0; i &amp;lt; 3; i++)
    actions.Add(() =&amp;gt; Console.WriteLine(i));
  foreach (var action in actions)
    action();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The sample contains a typical error. Newbie developers think that this code will output &lt;code&gt;&amp;quot;0 1 2&amp;quot;&lt;/code&gt;, but in fact it will output &lt;code&gt;&amp;quot;3 3 3&amp;quot;&lt;/code&gt;. Such strange behavior is easy to understand if you look on the expanded version of this method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  DisplayClass c = new DisplayClass();
  for (c.i = 0; c.i &amp;lt; 3; c.i++)
    list.Add(c.Action);
  foreach (Action action in list)
    action();
}

private sealed class DisplayClass
{
  public int i;

  public void Action()
  {
    Console.WriteLine(i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case they say that the variable is cycled by reference, not by value. Many programmers criticize this peculiarity of closures. They think it’s unclear though it’s quite logical for those who get a clear idea what’s inside the closures.&lt;/p&gt;
&lt;h3&gt;The foreach loop&lt;/h3&gt;
&lt;p&gt;Let’s review a more interesting sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  foreach (var i in Enumerable.Range(0, 3))
    actions.Add(() =&amp;gt; Console.WriteLine(i));
  foreach (var action in actions)
    action();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What will the code output? Sorry to say that there is no simple answer to this question. The matter is that earlier versions of C#, behavior of foreach was equal to behavior of for: variable of the cycle was created once and was captured in all lambdas. Starting from C# 5.0 this behavior has changed (&lt;a href=&quot;http://blogs.msdn.com/b/ericlippert/archive/2009/11/12/closing-over-the-loop-variable-considered-harmful.aspx&quot;&gt;here&lt;/a&gt; Eric Lippert admits that Microsoft made the breaking change). Now this code outputs &lt;code&gt;&amp;quot;0 1 2&amp;quot;&lt;/code&gt;. Note that this is a peculiarity of language, not of the platform. If you work in Visual Studio 2012 and change target framework to 3.5, nothing will change. And you will be able to see the old behavior in Visual Studio 2010. John Skit &lt;a href=&quot;http://stackoverflow.com/questions/16264289/captured-closure-loop-variable-in-c-sharp-5-0&quot;&gt;explains&lt;/a&gt; why it was decided to make different behavior for &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt;. Let’s have a look at a new variant of the expanded version of the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  foreach (int i in Enumerable.Range(0, 3))
  {
    DisplayClass c = new DisplayClass();
    с.i = i;    
    list.Add(c1.Action);
  }
  foreach (Action action in list)
    action();
}

private sealed class DisplayClass
{
  public int i;

  public void Action()
  {
    Console.WriteLine(i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can easily see the difference: in C# 5.0, for every iteration of the foreach cycle, we get a new instance of the generated class providing closure logic.&lt;/p&gt;
&lt;h3&gt;Closure of multiple variables&lt;/h3&gt;
&lt;p&gt;Let’s review a case when we get multiple variables that are captured in different variables:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  int x = 1, y = 2;
  Foo(u =&amp;gt; u + x, u =&amp;gt; u + y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One can think that in this case two additional classes are generated and each of them will be responsible for a single variable. Actually, a single class will be generated:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  DisplayClass с = new DisplayClass();
  с.x = 1;
  с.y = 2;
  Foo(с.ActionX, c.ActionY);
}

private sealed class DisplayClass
{
  public int x;
  public int y;

  public int ActionX(int u)
  {
    return u + x;
  }

  public int ActionY(int u)
  {
    return u + y;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thus, lambdas are bound; garbage collector will access them when no reference to either of them will remain. Imagine the situation when the first lambda is used when initiating a long-living object, the second one is used when completing the work with it. And let there be many such objects. In this case initializing lambdas will stay in memory for quite a long time, though no one will ever invoke them.&lt;/p&gt;
&lt;h3&gt;Scope&lt;/h3&gt;
&lt;p&gt;There is one more peculiarity of closures that you need to know. Let’s review a sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (var element in list)
  {
    var e = element;
    if (Condition(e))
      Foo(x =&amp;gt; x + e);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here is the question: where the closure object will be created? In spite the lambda is created inside &lt;code&gt;if&lt;/code&gt;, the object will be created in the same scope the captured variable is located in.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (int element in list)
  {
    DisplayClass c = new DisplayClass();
    c.e = element;
    if (Condition(c.e))
      Foo(c.Action);
  }
}

private sealed class DisplayClass
{
  public int e;

  public int Action(int x)
  {
    return x + e;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This peculiarity is important when the &lt;code&gt;list&lt;/code&gt; is quite big and the &lt;code&gt;Condition(e)&lt;/code&gt; is executed quite rarely. &lt;code&gt;DisplayClass&lt;/code&gt; instances will be created uselessly. It will affect memory and performance. We can fix the situation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (var element in list)
    if (Condition(element))
    {
      var e = element;
      Foo(x =&amp;gt; x + e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method will be deployed in a more optimal manner since &lt;code&gt;DisplayClass&lt;/code&gt; constructor will be invoked when it is really necessary:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (int element in list)
    if (Condition(element))
    {
      DisplayClass c = new DisplayClass();
      c.e = element;
      Foo(c.Action);
    }  
}

private sealed class DisplayClass
{
  public int e;
 
  public int Action(int x)
  {
    return x + e;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Problems&lt;/h3&gt;
&lt;p&gt;You can find problems about the subject in &lt;a href=&quot;http://problembook.net&quot;&gt;ProblemBook.NET&lt;/a&gt;:
&lt;a href=&quot;http://problembook.net/content/en/Linq/ClosureAndForeach-P.html&quot;&gt;ClosureAndForeach&lt;/a&gt;,
&lt;a href=&quot;http://problembook.net/content/en/Linq/ClosureAndFor-P.html&quot;&gt;ClosureAndFor&lt;/a&gt;,
&lt;a href=&quot;http://problembook.net/content/en/Linq/ClosureAndVariable-P.html&quot;&gt;ClosureAndVariable&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;It’s very convenient to use the following utility: &lt;a href=&quot;http://www.jetbrains.com/decompiler/&quot;&gt;dotPeek&lt;/a&gt; from &lt;a href=&quot;http://www.jetbrains.com/&quot;&gt;JetBrains&lt;/a&gt; with enabled option &lt;em&gt;Show compiler-generated code&lt;/em&gt;. Code included in the article is simplified in comparison with the disassembled version to make it easy to read.&lt;/p&gt;</content>
          </entry>
          <entry>
              <id>http://aakinshin.net/en/blog/dotnet/wrap-cs-in-com/</id>
              <link type="text/html" rel="alternate" href='http://aakinshin.net/en/blog/dotnet/wrap-cs-in-com/'/>
              <title>Wrapping C# class for use in COM</title>
              <updated>2013-06-02T21:14:00Z</updated>
              <author>
                  <name>Andrey Akinshin</name>
                  <uri>http://aakinshin.net/</uri>
              </author>
              <content type="html">&lt;p&gt;Let us have a C# class that makes something useful, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Calculator
{
    public int Sum(int a, int b)
    {
        return a + b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s create a &lt;a href=&quot;http://ru.wikipedia.org/wiki/Component_Object_Model&quot;&gt;COM&lt;/a&gt; interface for this class to make it possible to use its functionality in other areas. At the end we will see how this class is used in Delphi environment.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;For a beginning, we proceed to the project properties and check &lt;em&gt;Register for COM interop&lt;/em&gt; on the &lt;em&gt;Build&lt;/em&gt; tab.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/wrap-cs-in-com/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Create an interface for our class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public interface ICalculator
{
    int Sum(int a, int b);
}

public class Calculator : ICalculator
{
    public int Sum(int a, int b)
    {
        return a + b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s necessary to mark the class and the interface with a set of attributes: it’s necessary to specify unique &lt;a href=&quot;http://ru.wikipedia.org/wiki/GUID&quot;&gt;GUID&lt;/a&gt;’s for them, set &lt;code&gt;ComVisible(true)&lt;/code&gt;,and add the &lt;code&gt;ClassInterface(ClassInterfaceType.None)&lt;/code&gt; attribute to the class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Guid(&amp;quot;364C5E66-4412-48E3-8BD8-7B2BF09E8922&amp;quot;)]
[ComVisible(true)]
public interface ICalculator
{
    int Sum(int a, int b);
}

[Guid(&amp;quot;8C034F6A-1D3F-4DB8-BC99-B73873D8C297&amp;quot;)]
[ClassInterface(ClassInterfaceType.None)]
[ComVisible(true)]
public class Calculator : ICalculator
{
    public int Sum(int a, int b)
    {
        return a + b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re almost done! Now we can build the assembly. Since we checked &lt;em&gt;Register for COM interop&lt;/em&gt;, the COM component will be registered in the system automatically. It’s also possible to register it manually. You can do it with the &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/tzat5yw6.aspx&quot;&gt;RegAsm&lt;/a&gt; utility located here: &lt;code&gt;C:\Windows\Microsoft.NET\Framework\v &amp;lt; necessary version number &amp;gt;\&lt;/code&gt;. The corresponding tlb file can be created with the help of the &lt;code&gt;/tlb&lt;/code&gt; argument. The &lt;code&gt;/u&lt;/code&gt; argument will &lt;a href=&quot;http://stackoverflow.com/questions/7841428/how-to-unregister-the-assembly-registered-using-regasm&quot;&gt;cancel&lt;/a&gt; assembly registration. So, let’s execute the command (assume that name of the project and the corresponding dll is ComCalculator):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RegAsm.exe Calculator.dll /tlb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great! The component is registered! Run Delphi and try to use it. After a new project is created (a common WinForms project), it’s necessary to import ComCalculator to it. Select &lt;code&gt;Import Type Library&lt;/code&gt; from the &lt;code&gt;Project&lt;/code&gt; menu. Look for &lt;code&gt;ComCalculator&lt;/code&gt; and click &lt;code&gt;Install&lt;/code&gt;.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/wrap-cs-in-com/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;You need to add &lt;code&gt;ComCalculator_TLB&lt;/code&gt; to the &lt;code&gt;uses&lt;/code&gt; section in the &lt;code&gt;Unit1.pas&lt;/code&gt; file. After that you &lt;a href=&quot;http://stackoverflow.com/questions/7196769/what-is-this-error-mscorlib-tlb-pas&quot;&gt;can get some issues&lt;/a&gt; with compilation of &lt;code&gt;mscorlib_TBL.pas&lt;/code&gt;. If that’s the case, you just need to delete reference to it from the &lt;code&gt;uses&lt;/code&gt; section of the &lt;code&gt;ComCalculator_TLB.pas&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;Now let’s try to use our COM component. We will do it directly in the form constructor. The constructor body will contain two simple lines of code: the first one will contain instance of the &lt;code&gt;TCalculator&lt;/code&gt; class, in the second one, we will call the &lt;code&gt;Sum&lt;/code&gt; method. Calculation result will be shown with the help of the &lt;code&gt;ShowMessage&lt;/code&gt; procedure.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-delphi&quot;&gt;procedure TForm1.FormCreate(Sender: TObject);
var
  calculator : TCalculator;
begin
  calculator := TCalculator.Create(Self);
  ShowMessage(IntToStr(calculator.Sum(1, 2)));
end;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running the application you will see the window with figure 3.&lt;/p&gt;
&lt;h2&gt;Links&lt;/h2&gt;
&lt;p&gt;I recommend reading the following article for more complicated variants of the creation of COM objects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/c3fd4a20.aspx&quot;&gt;MSDN: Example COM Class (C# Programming Guide)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/wrapping-c-class-for-use-in-com/&quot;&gt;blogs.perpetuumsoft.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>
          </entry>
</feed>